{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"COMP2701 - Introduction to Procedural Programming with C Overview For full course information bcit.ca . Course taken in Spring 2025 ( outline ) with Bob Langelaan . Midterm and Final in-person 5 quizzes, one each in weeks 3, 5, 7, 9, and 11 right at the start of class midterm is also on week 7 There will be 4 assignments There are also optional leetcode exercises The course basically just follows C How to Program -- Ninth Edition . We covered chapter 1-8 as well as a section 12.3.","title":"Home"},{"location":"#comp2701-introduction-to-procedural-programming-with-c","text":"","title":"COMP2701 - Introduction to Procedural Programming with C"},{"location":"#overview","text":"For full course information bcit.ca . Course taken in Spring 2025 ( outline ) with Bob Langelaan . Midterm and Final in-person 5 quizzes, one each in weeks 3, 5, 7, 9, and 11 right at the start of class midterm is also on week 7 There will be 4 assignments There are also optional leetcode exercises The course basically just follows C How to Program -- Ninth Edition . We covered chapter 1-8 as well as a section 12.3.","title":"Overview"},{"location":"final/","text":"Final Exam Review Review the Midterm Notes Dynamic Memory Allocation C lets you request memory at runtime using functions like malloc() instead of hardcoding array sizes at compile time. This avoids wasted memory and allows data structures like lists and dynamic arrays. C has no garbage collection \u2014 you must manually free memory when done using free() . malloc(size) Allocates a block of uninitialized memory. int *arr = malloc(sizeof(int) * 4); if (arr == NULL) { return EXIT_FAILURE; } Use malloc when: The number of elements is determined at runtime (e.g., user input) You're allocating large arrays that may not fit on the stack You're building data structures where elements are created on demand (e.g., linked lists) You need to allocate memory inside a function and return it (or keep using it) after the function ends (without passing a pointer into the function). calloc(n, size) Like malloc , but zero-initializes the memory. int *arr = calloc(4, sizeof(int)); realloc(ptr, new_size) Changes the size of previously allocated memory. free(ptr) Releases memory. Set pointer to NULL afterward to avoid dangling references. free(arr); arr = NULL; sizeof with Pointers sizeof(ptr) // size of the pointer (e.g. 8 bytes) sizeof(*ptr) // size of the pointed-to type (e.g. 4 bytes for int) If you have a pointer to an array, calling sizeof will not give you the size of the pointed to array but instead the size of a pointer. Pointers and the Heap A pointer stores the memory address of another variable. When dynamically allocating: int *ptr = malloc(sizeof(int)); *ptr = 10; // Dereference to assign Pointer itself lives on the stack Value it points to lives on the heap (since it was malloc'd in this example). Dynamic Memory for Strings To handle string input of unknown length: char buffer[81]; scanf(\"%80[^ ]\", buffer); getchar(); // consume ' ' size_t len = strlen(buffer); char *copy = malloc(len + 1); strcpy(copy, buffer); Scanset %80[^ ] tells scanf to read up to 80 characters until newline. - [^...] : match anything except characters inside Pointers Pointers are variables that store memory addresses. Why Use Pointers? C uses pass-by-value , so variables are copied when passed to functions. To modify the original variable, pass its address using pointers. Pointers let us: - Avoid global variables - Share memory between functions - Modify original values in functions Indirection Using a pointer to access a value is called indirection . int count = 7; int *countPtr = &count; printf(\"%d\", *countPtr); // prints 7 Pointer Size Pointers match the CPU register width: 32-bit systems: 4-byte pointers 64-bit systems: 8-byte pointers Declaring a Pointer int *ptr; All of these are equivalent: int *ptr; int* ptr; int * ptr; Avoid multiple declarations like: int *ptr, x; // only ptr is a pointer Instead: int *ptr; int x; Initializing a Pointer Always initialize, even to NULL : int *ptr = NULL; The Address ( & ) Operator Returns the memory address of a variable: int y = 5; int *yPtr = &y; The Indirection ( * ) Operator Dereferences the pointer to get the value: int x = 10; int *ptr = &x; printf(\"%d\", *ptr); // prints 10 * means: In declarations: declare a pointer In expressions: dereference the pointer const with Pointers const affects either the data or the pointer : const double *dPtr; // can't change value pointed to double *const dPtr; // can't change the pointer itself const double *const dPtr; // can't change either When to use const on the pointer This mainly matters when the pointer refers to something you can iterate over (like an array or buffer): if you plan to iterate over the pointer, no const after * if you plan to never iterate ( always point to the same element), const after * When to use const on the data Same idea as const in other languages: not changing the underlying value, const on data type changing the underlying value, no const on data type Incrementing a Pointer int arr[] = {1, 2, 3}; int *ptr = arr; ++ptr; // now points to arr[1] Increment moves to the next element, not just next byte. Pointer increment inside a function only affects the local copy unless passed as a pointer-to-pointer. sizeof Operator sizeof is a compile-time operator (not a function) that returns the size (in bytes) of a type or object as a size_t . int array[20]; printf(\"%zu\", sizeof array); // prints 80 if int is 4 bytes sizeof(type) requires parentheses. sizeof(variable) does not. Pointers and sizeof When used on a pointer, sizeof returns the size of the pointer itself \u2014 not what it points to. int *p; sizeof(p); // size of pointer (e.g., 8 bytes) sizeof(*p); // size of int (e.g., 4 bytes) Arrays decay to pointers when passed to functions, so sizeof no longer gives array size inside a function. Pointer Arithmetic Valid operations: - ++ , -- - + and - with integers - subtracting one pointer from another When you add n to a pointer, it advances by n * sizeof(type) bytes. myPtr += 2; // skips 2 elements, not 2 bytes Subtracting Pointers int *a, *b; // suppose a = 0x1000, b = 0x1008, and sizeof(int) = 4 b - a; // result is 2 (elements apart) Pointing to Arrays int arr[] = {0, 1, 2}; int *ptr = arr; // same as &arr[0] Offset Notation arr[3] == *(arr + 3) ptr[2] == *(ptr + 2) Always use parentheses: *(arr + i) Not: *arr + i (which adds after dereferencing) void * Pointers Generic pointer type. Can point to any data type. void *vp; int *ip = vp; // allowed with explicit cast Cannot dereference a void * directly \u2014 must cast to a specific type first. Function Pointers Functions have addresses just like data. void bubbleSort(int a[], size_t n, int (*cmp)(int, int)); Calling: (*cmp)(a, b); Parentheses around *cmp are required to make it a pointer to a function. <ctype.h> \u2013 Character Classification Each function takes an int (usually a char cast to int ). Type Checking isdigit(c) \u2013 true if 0\u20139 isalpha(c) \u2013 true if a\u2013z or A\u2013Z isalnum(c) \u2013 true if letter or digit isxdigit(c) \u2013 true if valid hex (0\u20139, a\u2013f, A\u2013F) Case Checking and Conversion islower(c) \u2013 true if lowercase isupper(c) \u2013 true if uppercase tolower(c) \u2013 converts to lowercase toupper(c) \u2013 converts to uppercase Whitespace & Control isblank(c) \u2013 space or tab isspace(c) \u2013 any whitespace (space, tab, newline, etc.) iscntrl(c) \u2013 control characters (e.g., newline, tab) ispunct(c) \u2013 punctuation (not space or alphanumeric) Printable Characters isprint(c) \u2013 any printable char, including space isgraph(c) \u2013 printable except space <stdlib.h> \u2013 String Conversion Conversion Functions strtod(s, endPtr) \u2013 string to double strtol(s, endPtr, base) \u2013 string to long strtoul(s, endPtr, base) \u2013 string to unsigned long Behavior: - Stops at first invalid char - base = 0 auto-detects: - 0x or 0X \u2192 hex - 0 \u2192 octal - otherwise \u2192 decimal <stdio.h> \u2013 Input/Output getchar() \u2013 reads next char from stdin putchar(c) \u2013 writes char to stdout puts(s) \u2013 prints string with newline sprintf(dest, format, ...) \u2013 formats into a string sscanf(s, format, ...) \u2013 parses from string fgets(s, n, stream) \u2013 reads up to n-1 chars, stops at newline or EOF, includes newline Example (safe input): char buffer[100]; int value; if (fgets(buffer, sizeof buffer, stdin)) { if (sscanf(buffer, \"%d\", &value) == 1) { printf(\"Value: %d\\n\", value); } } <string.h> \u2013 String Handling Copying and Concatenation strcpy(dest, src) \u2013 copies string including NUL strncpy(dest, src, n) \u2013 at most n chars; may not NUL-terminate strcat(dest, src) \u2013 appends src to dest strncat(dest, src, n) \u2013 appends at most n chars Comparing Strings strcmp(s1, s2) \u2013 full comparison strncmp(s1, s2, n) \u2013 compares first n chars Searching strchr(s, c) \u2013 first occurrence of c strrchr(s, c) \u2013 last occurrence of c strpbrk(s1, s2) \u2013 first match of any char from s2 strstr(s1, s2) \u2013 first substring match strspn(s1, s2) \u2013 length of segment with only s2 chars strcspn(s1, s2) \u2013 length of segment with no s2 chars strtok \u2013 Tokenizing char *token = strtok(str, \" ,.-\"); while (token != NULL) { // process token token = strtok(NULL, \" ,.-\"); } Modifies input string Remembers position using internal static storage Start new string by calling again with non-NULL Memory Functions (Raw Byte Handling) Work on any data, not just strings memcpy(dest, src, n) \u2013 fast copy, no overlap safety memmove(dest, src, n) \u2013 overlap-safe copy memcmp(s1, s2, n) \u2013 compares n bytes memchr(s, c, n) \u2013 searches first n bytes for c memset(s, c, n) \u2013 fills memory with byte c strlen Returns length of a string excluding the null terminator. size_t len = strlen(\"hello\"); // 5","title":"Final Exam Review"},{"location":"final/#final-exam-review","text":"Review the Midterm Notes","title":"Final Exam Review"},{"location":"final/#dynamic-memory-allocation","text":"C lets you request memory at runtime using functions like malloc() instead of hardcoding array sizes at compile time. This avoids wasted memory and allows data structures like lists and dynamic arrays. C has no garbage collection \u2014 you must manually free memory when done using free() .","title":"Dynamic Memory Allocation"},{"location":"final/#mallocsize","text":"Allocates a block of uninitialized memory. int *arr = malloc(sizeof(int) * 4); if (arr == NULL) { return EXIT_FAILURE; } Use malloc when: The number of elements is determined at runtime (e.g., user input) You're allocating large arrays that may not fit on the stack You're building data structures where elements are created on demand (e.g., linked lists) You need to allocate memory inside a function and return it (or keep using it) after the function ends (without passing a pointer into the function).","title":"malloc(size)"},{"location":"final/#callocn-size","text":"Like malloc , but zero-initializes the memory. int *arr = calloc(4, sizeof(int));","title":"calloc(n, size)"},{"location":"final/#reallocptr-new_size","text":"Changes the size of previously allocated memory.","title":"realloc(ptr, new_size)"},{"location":"final/#freeptr","text":"Releases memory. Set pointer to NULL afterward to avoid dangling references. free(arr); arr = NULL;","title":"free(ptr)"},{"location":"final/#sizeof-with-pointers","text":"sizeof(ptr) // size of the pointer (e.g. 8 bytes) sizeof(*ptr) // size of the pointed-to type (e.g. 4 bytes for int) If you have a pointer to an array, calling sizeof will not give you the size of the pointed to array but instead the size of a pointer.","title":"sizeof with Pointers"},{"location":"final/#pointers-and-the-heap","text":"A pointer stores the memory address of another variable. When dynamically allocating: int *ptr = malloc(sizeof(int)); *ptr = 10; // Dereference to assign Pointer itself lives on the stack Value it points to lives on the heap (since it was malloc'd in this example).","title":"Pointers and the Heap"},{"location":"final/#dynamic-memory-for-strings","text":"To handle string input of unknown length: char buffer[81]; scanf(\"%80[^ ]\", buffer); getchar(); // consume ' ' size_t len = strlen(buffer); char *copy = malloc(len + 1); strcpy(copy, buffer);","title":"Dynamic Memory for Strings"},{"location":"final/#scanset","text":"%80[^ ] tells scanf to read up to 80 characters until newline. - [^...] : match anything except characters inside","title":"Scanset"},{"location":"final/#pointers","text":"Pointers are variables that store memory addresses.","title":"Pointers"},{"location":"final/#why-use-pointers","text":"C uses pass-by-value , so variables are copied when passed to functions. To modify the original variable, pass its address using pointers. Pointers let us: - Avoid global variables - Share memory between functions - Modify original values in functions","title":"Why Use Pointers?"},{"location":"final/#indirection","text":"Using a pointer to access a value is called indirection . int count = 7; int *countPtr = &count; printf(\"%d\", *countPtr); // prints 7","title":"Indirection"},{"location":"final/#pointer-size","text":"Pointers match the CPU register width: 32-bit systems: 4-byte pointers 64-bit systems: 8-byte pointers","title":"Pointer Size"},{"location":"final/#declaring-a-pointer","text":"int *ptr; All of these are equivalent: int *ptr; int* ptr; int * ptr; Avoid multiple declarations like: int *ptr, x; // only ptr is a pointer Instead: int *ptr; int x;","title":"Declaring a Pointer"},{"location":"final/#initializing-a-pointer","text":"Always initialize, even to NULL : int *ptr = NULL;","title":"Initializing a Pointer"},{"location":"final/#the-address-operator","text":"Returns the memory address of a variable: int y = 5; int *yPtr = &y;","title":"The Address (&amp;) Operator"},{"location":"final/#the-indirection-operator","text":"Dereferences the pointer to get the value: int x = 10; int *ptr = &x; printf(\"%d\", *ptr); // prints 10 * means: In declarations: declare a pointer In expressions: dereference the pointer","title":"The Indirection (*) Operator"},{"location":"final/#const-with-pointers","text":"const affects either the data or the pointer : const double *dPtr; // can't change value pointed to double *const dPtr; // can't change the pointer itself const double *const dPtr; // can't change either","title":"const with Pointers"},{"location":"final/#when-to-use-const-on-the-pointer","text":"This mainly matters when the pointer refers to something you can iterate over (like an array or buffer): if you plan to iterate over the pointer, no const after * if you plan to never iterate ( always point to the same element), const after *","title":"When to use const on the pointer"},{"location":"final/#when-to-use-const-on-the-data","text":"Same idea as const in other languages: not changing the underlying value, const on data type changing the underlying value, no const on data type","title":"When to use const on the data"},{"location":"final/#incrementing-a-pointer","text":"int arr[] = {1, 2, 3}; int *ptr = arr; ++ptr; // now points to arr[1] Increment moves to the next element, not just next byte. Pointer increment inside a function only affects the local copy unless passed as a pointer-to-pointer.","title":"Incrementing a Pointer"},{"location":"final/#sizeof-operator","text":"sizeof is a compile-time operator (not a function) that returns the size (in bytes) of a type or object as a size_t . int array[20]; printf(\"%zu\", sizeof array); // prints 80 if int is 4 bytes sizeof(type) requires parentheses. sizeof(variable) does not.","title":"sizeof Operator"},{"location":"final/#pointers-and-sizeof","text":"When used on a pointer, sizeof returns the size of the pointer itself \u2014 not what it points to. int *p; sizeof(p); // size of pointer (e.g., 8 bytes) sizeof(*p); // size of int (e.g., 4 bytes) Arrays decay to pointers when passed to functions, so sizeof no longer gives array size inside a function.","title":"Pointers and sizeof"},{"location":"final/#pointer-arithmetic","text":"Valid operations: - ++ , -- - + and - with integers - subtracting one pointer from another When you add n to a pointer, it advances by n * sizeof(type) bytes. myPtr += 2; // skips 2 elements, not 2 bytes","title":"Pointer Arithmetic"},{"location":"final/#subtracting-pointers","text":"int *a, *b; // suppose a = 0x1000, b = 0x1008, and sizeof(int) = 4 b - a; // result is 2 (elements apart)","title":"Subtracting Pointers"},{"location":"final/#pointing-to-arrays","text":"int arr[] = {0, 1, 2}; int *ptr = arr; // same as &arr[0]","title":"Pointing to Arrays"},{"location":"final/#offset-notation","text":"arr[3] == *(arr + 3) ptr[2] == *(ptr + 2) Always use parentheses: *(arr + i) Not: *arr + i (which adds after dereferencing)","title":"Offset Notation"},{"location":"final/#void-pointers","text":"Generic pointer type. Can point to any data type. void *vp; int *ip = vp; // allowed with explicit cast Cannot dereference a void * directly \u2014 must cast to a specific type first.","title":"void * Pointers"},{"location":"final/#function-pointers","text":"Functions have addresses just like data. void bubbleSort(int a[], size_t n, int (*cmp)(int, int)); Calling: (*cmp)(a, b); Parentheses around *cmp are required to make it a pointer to a function.","title":"Function Pointers"},{"location":"final/#ctypeh-character-classification","text":"Each function takes an int (usually a char cast to int ).","title":"&lt;ctype.h&gt; \u2013 Character Classification"},{"location":"final/#type-checking","text":"isdigit(c) \u2013 true if 0\u20139 isalpha(c) \u2013 true if a\u2013z or A\u2013Z isalnum(c) \u2013 true if letter or digit isxdigit(c) \u2013 true if valid hex (0\u20139, a\u2013f, A\u2013F)","title":"Type Checking"},{"location":"final/#case-checking-and-conversion","text":"islower(c) \u2013 true if lowercase isupper(c) \u2013 true if uppercase tolower(c) \u2013 converts to lowercase toupper(c) \u2013 converts to uppercase","title":"Case Checking and Conversion"},{"location":"final/#whitespace-control","text":"isblank(c) \u2013 space or tab isspace(c) \u2013 any whitespace (space, tab, newline, etc.) iscntrl(c) \u2013 control characters (e.g., newline, tab) ispunct(c) \u2013 punctuation (not space or alphanumeric)","title":"Whitespace &amp; Control"},{"location":"final/#printable-characters","text":"isprint(c) \u2013 any printable char, including space isgraph(c) \u2013 printable except space","title":"Printable Characters"},{"location":"final/#stdlibh-string-conversion","text":"","title":"&lt;stdlib.h&gt; \u2013 String Conversion"},{"location":"final/#conversion-functions","text":"strtod(s, endPtr) \u2013 string to double strtol(s, endPtr, base) \u2013 string to long strtoul(s, endPtr, base) \u2013 string to unsigned long Behavior: - Stops at first invalid char - base = 0 auto-detects: - 0x or 0X \u2192 hex - 0 \u2192 octal - otherwise \u2192 decimal","title":"Conversion Functions"},{"location":"final/#stdioh-inputoutput","text":"getchar() \u2013 reads next char from stdin putchar(c) \u2013 writes char to stdout puts(s) \u2013 prints string with newline sprintf(dest, format, ...) \u2013 formats into a string sscanf(s, format, ...) \u2013 parses from string fgets(s, n, stream) \u2013 reads up to n-1 chars, stops at newline or EOF, includes newline Example (safe input): char buffer[100]; int value; if (fgets(buffer, sizeof buffer, stdin)) { if (sscanf(buffer, \"%d\", &value) == 1) { printf(\"Value: %d\\n\", value); } }","title":"&lt;stdio.h&gt; \u2013 Input/Output"},{"location":"final/#stringh-string-handling","text":"","title":"&lt;string.h&gt; \u2013 String Handling"},{"location":"final/#copying-and-concatenation","text":"strcpy(dest, src) \u2013 copies string including NUL strncpy(dest, src, n) \u2013 at most n chars; may not NUL-terminate strcat(dest, src) \u2013 appends src to dest strncat(dest, src, n) \u2013 appends at most n chars","title":"Copying and Concatenation"},{"location":"final/#comparing-strings","text":"strcmp(s1, s2) \u2013 full comparison strncmp(s1, s2, n) \u2013 compares first n chars","title":"Comparing Strings"},{"location":"final/#searching","text":"strchr(s, c) \u2013 first occurrence of c strrchr(s, c) \u2013 last occurrence of c strpbrk(s1, s2) \u2013 first match of any char from s2 strstr(s1, s2) \u2013 first substring match strspn(s1, s2) \u2013 length of segment with only s2 chars strcspn(s1, s2) \u2013 length of segment with no s2 chars","title":"Searching"},{"location":"final/#strtok-tokenizing","text":"char *token = strtok(str, \" ,.-\"); while (token != NULL) { // process token token = strtok(NULL, \" ,.-\"); } Modifies input string Remembers position using internal static storage Start new string by calling again with non-NULL","title":"strtok \u2013 Tokenizing"},{"location":"final/#memory-functions-raw-byte-handling","text":"","title":"Memory Functions (Raw Byte Handling)"},{"location":"final/#work-on-any-data-not-just-strings","text":"memcpy(dest, src, n) \u2013 fast copy, no overlap safety memmove(dest, src, n) \u2013 overlap-safe copy memcmp(s1, s2, n) \u2013 compares n bytes memchr(s, c, n) \u2013 searches first n bytes for c memset(s, c, n) \u2013 fills memory with byte c","title":"Work on any data, not just strings"},{"location":"final/#strlen","text":"Returns length of a string excluding the null terminator. size_t len = strlen(\"hello\"); // 5","title":"strlen"},{"location":"midterm/","text":"Midterm Review Six Phases of C Program Development Editing/Programming : Write source code. Preprocess : Handle directives like #include (copies file contents) and #define (text replacement). Compile : Check syntax, generate .o object files with machine code. Link : Combine .o files and C library into an executable. Load : OS loads executable into memory. Execute : CPU runs program starting from main() . Main Function Every C program requires a main() function. #include <stdio.h> int main(void) { printf(\"Hello World\\n\"); return 0; } Variables Statically Typed : Declare type before use (e.g., int , float , char ). When naming variables, they must start with letter/underscore and can contain letters/digits/underscores. int a = 3; float b = 5.5; char c = 'A'; Preprocessor Directives #include : Import library functions (e.g., #include <stdio.h> ). #define : Define symbolic constants to avoid magic numbers. #define MAX 100 for(int i = 0; i < MAX; ++i) { ... } Input/Output Output : puts() : Prints string with automatic newline. printf() : Uses format specifiers ( %d , %c , %f ) for dynamic output, no automatic newline. printf(\"You entered %d.\\n\", number); Input : scanf() : Reads input with format specifiers, requires variable address ( & ) except for strings. int num; scanf(\"%d\", &num); char name[20]; scanf(\"%19s\", name); // No & for strings Operators Arithmetic : + , - , * , / , % Assignment : = , += , -= , *= , /= , %= . Comparison : == , != , < , > , <= , >= (return 1 or 0). Logical : && (AND), || (OR), ! (NOT), uses short-circuit evaluation. Note : We can use casting to convert types for precision (for example, keeping decimal places when dividing two integers by casting one to a float). float result = (float)2 / 3; // 0.67 printf(\"%.2f\\n\", result); Algorithms Procedure for solving a problem with actions to execute and execution order of those actions (program control). Control Structures Three types of control structures: sequence , selection , and iteration . Sequence Statements execute in order. Selection Choose based on condition. if , if...else , switch : Ternary Operator ( ?: ) is a concise if...else . puts(x > 0 ? \"good\" : \"bad\"); Iteration Repeat until condition met. for , while , do...while Increment/Decrement Pre-increment ( ++x ): Increment first. Post-increment ( x++ ): Use, then increment. Bob insists we use pre-increment in loop continuation conditions: for(int i = 0; i < 10; ++i) { ... } Functions Self-contained code for specific tasks. They help: Divide and Conquer : Build programs from reusable parts. Abstraction : Hide implementation details behind function names. Decomposition : Break complex problems into smaller functions. A function is like a worker. It is invoked/called by another function which can be thought of as its boss. Function Definition return_type function_name(parameters) { statements } Example: int square(int number) { return number * number; } Function Prototype Due to C being sequential, we must declare function before use to avoid errors. A prototype allows us to declare a function up front and define it later. Example: int square(int); ... int square(int i) { return i*i; } Note: the variable name used in the prototype is meaningless (and can be skipped) only the type matters. Argument Coercion : When passing arguments to a function or assigning between variables, C will automatically convert values to the expected type if needed. This may cause data loss (e.g., double to int drops decimals). Function-Call Stack The function call stack is a last-in, first-out (LIFO) structure for function calls/returns. In the function call stack, we push a frame with return address on function call and pop from the stack on return. If you do excessive pushes to the stack, we will get a Stack overflow when we run out of space in memory. Pass Arguments By Value : Copies argument; original unchanged. All arguments in C are passed by value. void superFunction(int num) { num *= 1000; } // No effect on original By Reference : Modifies original. Need to use pointers to achieve this in C. Random-Number Generation From <stdlib.h> : rand() : Returns an int between 0 and RAND_MAX (\u226532,767). srand(seed) : Sets seed. Use mod % and the number of values your range is in. Offset it as needed. int dice = 1 + (rand() % 6); // 1 to 6 Use srand(time(NULL)) for unique sequences. Enumerated Types Programmer-defined types listing all valid values. enum DaysOfWeek {SUN, MON, TUES, WED, THU, FRI, SAT}; enum DaysOfWeek today = MON; // Assigns 1 Default starts at 0, increments by 1; can set explicit values. enum Status {CONTINUE = 0, WON = 1, LOST = 2}; Storage Classes Storage classes set some attributes of variables such as: storage duration (lifetime), scope (visibility), linkage (file access). auto : Default for local variables; stored on stack (rarely used explicitly). register : Requests CPU register storage (mostly obsolete; ignored by modern compilers). static : Persistent lifetime; local retains value between calls, global restricts to file. extern : Declares variable/function in another file; no storage created. Easy to remember since storage classes are ARSE - a uto, r egister, s tatic, e xtern. Scope Function Scope : Labels (e.g., goto , switch ) visible in function. File Scope : Global variables, function prototypes outside functions; visible from declaration to file end. Block Scope : Variables in {} Function-Prototype Scope : Parameter names in prototypes (optional, ignored by compiler). Memory Regions Stack : Automatic variables; allocated/deallocated with block scope. Static : Global/static local variables; persist entire program, initialized once. Heap : Dynamic memory (via malloc() , calloc() , realloc() ); manually managed. Arrays Group of same-type elements stored contiguously in memory. Use array name with 0-based index to access an element (e.g., my_array[3] for fourth element). int my_arr[3]; // Static size, cannot be resized Best Practice : Use #define for array size to avoid magic numbers. Looping : Use size_t for index in loops. for (size_t i = 0; i < 5; ++i) { n[i] = i; } Initializer Lists : int n[5] = {32, 27, 64, 18, 95}; // Sets values int n[5] = {0}; // Sets all to 0 Strings Array of char terminated by '\\0' (NUL). char s1[] = \"hello\"; // Auto-sized, NUL added char s2[10] = \"hello\"; // Fixed size, must fit NUL char s3[] = {'h', 'e', 'l', 'l', 'o', '\\0'}; // Manual NUL char buf[20]; scanf(\"%19s\", buf); // No & needed, size limits input Static vs Automatic Arrays Static Array : Single instance, persists entire program, initialized to 0. Automatic Array : New instance per function call, contains garbage unless initialized. static int s_arr[3]; // Persists, 0-initialized int a_arr[3]; // New each call, garbage values Passing an Array to a Function When passing an array to a function, we need to also supply the size of the array: void myFunc(int myArr[], size_t size); Alternatively we can use pointer syntax: void myFunc(int *myArr, size_t size); When calling the function, simply pass the array name (no brackets [] , no * ): myFunc(myArr, size) This passes a pointer to the first element of the array. The function can modify the original array (similar to pass by reference). If we do not want the function to be able to modify the array (e.g. for searching/reading), we can pass it as const to the function: void searchArray(const int arr[], size_t size); Note: If we pass an individual element of the array, such as myArr[3] that is passed by value and because of this it does not modify the original array. Multi-Dimensional Arrays Arrays of arrays (e.g., 2D array like a spreadsheet). First index is row, second is column (e.g., arr[row][col] ). Stored in row-major order (row by row) in contiguous 1D memory. Initializer Lists : int arr[3][3] = {{0, 1, 2}, {3, 4, 5}, {6, 7, 8}}; // Readable int arr[3][3] = {0, 1, 2, 3, 4, 5, 6, 7, 8}; // Same memory layout Passing to Functions : You must specify all dimension sizes except first (e.g., void printArray(int arr[][3], size_t nRows) ). Looping : Use descriptive indices (e.g., row , col ) instead of i , j . for (size_t row = 0; row < 3; ++row) { for (size_t col = 0; col < 3; ++col) { printf(\"%d \", arr[row][col]); } printf(\"\\n\"); } Variable-Length Arrays (VLAs) Arrays sized at runtime (e.g., int arr[size] where size is user input). Bob says do not use in this course. Functions to be able to create from Weeks 5 and 6 Find max value in array int arr_max(const int a[], size_t n) { int max = a[0]; for (unsigned int i = 1; i < n; ++i) { if (a[i] > max) { max = a[i]; } } return max; } Index of first max value size_t arr_index_of_first_max(const int a[], size_t n) { int max = a[0]; int index = 0; for (unsigned int i = 1; i < n; ++i) { if (a[i] > max) { max = a[i]; index = i; } } return index; } Index of last max value size_t arr_index_of_last_max(const int a[], size_t n) { int max = a[0]; int index = 0; for (unsigned int i = 1; i < n; ++i) { if (a[i] >= max) { max = a[i]; index = i; } } return index; } Index of first occurrence of value int arr_index_of_value_first(const int a[], size_t n, int value) { for (unsigned int i = 0; i < n; ++i) { if (a[i] == value) { return i; } } return -1; } Index of last occurrence of value int arr_index_of_value_last(const int a[], size_t n, int value) { int index = -1; for (unsigned int i = 0; i < n; ++i) { if (a[i] == value) { index = i; } } return index; } Compare two arrays int arr_compare(const int a[], const int b[], size_t n) { for (unsigned int i = 0; i < n; ++i) { if (a[i] != b[i]) { return 0; } } return 1; } Find first occurrence of char int find_first(const char s[], char c) { for (int i = 0; s[i] != '\\0'; ++i) { if (s[i] == c) { return i; } } return -1; } Replace last occurrence of char int replace_last(char s[], char oldChar, char newChar) { int index = -1; for (int i = 0; s[i] != '\\0'; ++i) { if (s[i] == oldChar) { index = i; } } if (index != -1) { s[index] = newChar; } return index; } Count number of occurrences of char int count_occ(const char s[], char c) { int count = 0; for (int i = 0; s[i] != '\\0'; ++i) { if (s[i] == c) { ++count; } } return count; } Count alphabetic characters int count_alpha(const char s[]) { int count = 0; for (int i = 0; s[i] != '\\0'; ++i) { if (isalpha(s[i])) { ++count; } } return count; } Check if string is all digits int is_all_digits(const char s[]) { for (int i = 0; s[i] != '\\0'; ++i) { if (!isdigit(s[i])) { return 0; } } return 1; } Copy string to lowercase void lowercase_copy(char dest[], const char src[]) { int i; for (i = 0; src[i] != '\\0'; ++i) { dest[i] = tolower(src[i]); } dest[i] = '\\0'; } Validate BCIT ID int is_valid_bcit_id(const char id[]) { if (id[0] != 'a' && id[0] != 'A') { return 0; } int i; for (i = 1; (id[i] != '\\0') && (i < 10); ++i) { if (!isdigit(id[i])) { return 0; } } if (i != 9) { return 0; } return 1; } Return first word void return_first_word(const char input[], char output[]) { while ((*input != '\\0') && (isspace(*input))) { ++input; } while ((*input != '\\0') && (!isspace(*input))) { *output++ = *input++; } *output = '\\0'; } Return second word void return_second_word(const char input[], char output[]) { while ((*input != '\\0') && (isspace(*input))) { ++input; } while ((*input != '\\0') && (!isspace(*input))) { ++input; } while ((*input != '\\0') && (isspace(*input))) { ++input; } while ((*input != '\\0') && (!isspace(*input))) { *output++ = *input++; } *output = '\\0'; } Count number of words int return_count_of_words(const char input[]) { int count = 0; while ((*input != '\\0') && (isspace(*input))) { ++input; } while (*input != '\\0') { ++count; while ((*input != '\\0') && (!isspace(*input))) { ++input; } while ((*input != '\\0') && (isspace(*input))) { ++input; } } return count; } Return nth word void return_nth_word(const char input[], char output[], int n) { while ((*input != '\\0') && (isspace(*input))) { ++input; } int count = 1; while ((*input != '\\0') && (count < n)) { while ((*input != '\\0') && (!isspace(*input))) { ++input; } while ((*input != '\\0') && (isspace(*input))) { ++input; } ++count; } while ((*input != '\\0') && (!isspace(*input))) { *output++ = *input++; } *output = '\\0'; }","title":"Midterm Review"},{"location":"midterm/#midterm-review","text":"","title":"Midterm Review"},{"location":"midterm/#six-phases-of-c-program-development","text":"Editing/Programming : Write source code. Preprocess : Handle directives like #include (copies file contents) and #define (text replacement). Compile : Check syntax, generate .o object files with machine code. Link : Combine .o files and C library into an executable. Load : OS loads executable into memory. Execute : CPU runs program starting from main() .","title":"Six Phases of C Program Development"},{"location":"midterm/#main-function","text":"Every C program requires a main() function. #include <stdio.h> int main(void) { printf(\"Hello World\\n\"); return 0; }","title":"Main Function"},{"location":"midterm/#variables","text":"Statically Typed : Declare type before use (e.g., int , float , char ). When naming variables, they must start with letter/underscore and can contain letters/digits/underscores. int a = 3; float b = 5.5; char c = 'A';","title":"Variables"},{"location":"midterm/#preprocessor-directives","text":"#include : Import library functions (e.g., #include <stdio.h> ). #define : Define symbolic constants to avoid magic numbers. #define MAX 100 for(int i = 0; i < MAX; ++i) { ... }","title":"Preprocessor Directives"},{"location":"midterm/#inputoutput","text":"Output : puts() : Prints string with automatic newline. printf() : Uses format specifiers ( %d , %c , %f ) for dynamic output, no automatic newline. printf(\"You entered %d.\\n\", number); Input : scanf() : Reads input with format specifiers, requires variable address ( & ) except for strings. int num; scanf(\"%d\", &num); char name[20]; scanf(\"%19s\", name); // No & for strings","title":"Input/Output"},{"location":"midterm/#operators","text":"Arithmetic : + , - , * , / , % Assignment : = , += , -= , *= , /= , %= . Comparison : == , != , < , > , <= , >= (return 1 or 0). Logical : && (AND), || (OR), ! (NOT), uses short-circuit evaluation. Note : We can use casting to convert types for precision (for example, keeping decimal places when dividing two integers by casting one to a float). float result = (float)2 / 3; // 0.67 printf(\"%.2f\\n\", result);","title":"Operators"},{"location":"midterm/#algorithms","text":"Procedure for solving a problem with actions to execute and execution order of those actions (program control).","title":"Algorithms"},{"location":"midterm/#control-structures","text":"Three types of control structures: sequence , selection , and iteration .","title":"Control Structures"},{"location":"midterm/#sequence","text":"Statements execute in order.","title":"Sequence"},{"location":"midterm/#selection","text":"Choose based on condition. if , if...else , switch : Ternary Operator ( ?: ) is a concise if...else . puts(x > 0 ? \"good\" : \"bad\");","title":"Selection"},{"location":"midterm/#iteration","text":"Repeat until condition met. for , while , do...while","title":"Iteration"},{"location":"midterm/#incrementdecrement","text":"Pre-increment ( ++x ): Increment first. Post-increment ( x++ ): Use, then increment. Bob insists we use pre-increment in loop continuation conditions: for(int i = 0; i < 10; ++i) { ... }","title":"Increment/Decrement"},{"location":"midterm/#functions","text":"Self-contained code for specific tasks. They help: Divide and Conquer : Build programs from reusable parts. Abstraction : Hide implementation details behind function names. Decomposition : Break complex problems into smaller functions. A function is like a worker. It is invoked/called by another function which can be thought of as its boss.","title":"Functions"},{"location":"midterm/#function-definition","text":"return_type function_name(parameters) { statements } Example: int square(int number) { return number * number; }","title":"Function Definition"},{"location":"midterm/#function-prototype","text":"Due to C being sequential, we must declare function before use to avoid errors. A prototype allows us to declare a function up front and define it later. Example: int square(int); ... int square(int i) { return i*i; } Note: the variable name used in the prototype is meaningless (and can be skipped) only the type matters. Argument Coercion : When passing arguments to a function or assigning between variables, C will automatically convert values to the expected type if needed. This may cause data loss (e.g., double to int drops decimals).","title":"Function Prototype"},{"location":"midterm/#function-call-stack","text":"The function call stack is a last-in, first-out (LIFO) structure for function calls/returns. In the function call stack, we push a frame with return address on function call and pop from the stack on return. If you do excessive pushes to the stack, we will get a Stack overflow when we run out of space in memory.","title":"Function-Call Stack"},{"location":"midterm/#pass-arguments","text":"By Value : Copies argument; original unchanged. All arguments in C are passed by value. void superFunction(int num) { num *= 1000; } // No effect on original By Reference : Modifies original. Need to use pointers to achieve this in C.","title":"Pass Arguments"},{"location":"midterm/#random-number-generation","text":"From <stdlib.h> : rand() : Returns an int between 0 and RAND_MAX (\u226532,767). srand(seed) : Sets seed. Use mod % and the number of values your range is in. Offset it as needed. int dice = 1 + (rand() % 6); // 1 to 6 Use srand(time(NULL)) for unique sequences.","title":"Random-Number Generation"},{"location":"midterm/#enumerated-types","text":"Programmer-defined types listing all valid values. enum DaysOfWeek {SUN, MON, TUES, WED, THU, FRI, SAT}; enum DaysOfWeek today = MON; // Assigns 1 Default starts at 0, increments by 1; can set explicit values. enum Status {CONTINUE = 0, WON = 1, LOST = 2};","title":"Enumerated Types"},{"location":"midterm/#storage-classes","text":"Storage classes set some attributes of variables such as: storage duration (lifetime), scope (visibility), linkage (file access). auto : Default for local variables; stored on stack (rarely used explicitly). register : Requests CPU register storage (mostly obsolete; ignored by modern compilers). static : Persistent lifetime; local retains value between calls, global restricts to file. extern : Declares variable/function in another file; no storage created. Easy to remember since storage classes are ARSE - a uto, r egister, s tatic, e xtern.","title":"Storage Classes"},{"location":"midterm/#scope","text":"Function Scope : Labels (e.g., goto , switch ) visible in function. File Scope : Global variables, function prototypes outside functions; visible from declaration to file end. Block Scope : Variables in {} Function-Prototype Scope : Parameter names in prototypes (optional, ignored by compiler).","title":"Scope"},{"location":"midterm/#memory-regions","text":"Stack : Automatic variables; allocated/deallocated with block scope. Static : Global/static local variables; persist entire program, initialized once. Heap : Dynamic memory (via malloc() , calloc() , realloc() ); manually managed.","title":"Memory Regions"},{"location":"midterm/#arrays","text":"Group of same-type elements stored contiguously in memory. Use array name with 0-based index to access an element (e.g., my_array[3] for fourth element). int my_arr[3]; // Static size, cannot be resized Best Practice : Use #define for array size to avoid magic numbers. Looping : Use size_t for index in loops. for (size_t i = 0; i < 5; ++i) { n[i] = i; } Initializer Lists : int n[5] = {32, 27, 64, 18, 95}; // Sets values int n[5] = {0}; // Sets all to 0","title":"Arrays"},{"location":"midterm/#strings","text":"Array of char terminated by '\\0' (NUL). char s1[] = \"hello\"; // Auto-sized, NUL added char s2[10] = \"hello\"; // Fixed size, must fit NUL char s3[] = {'h', 'e', 'l', 'l', 'o', '\\0'}; // Manual NUL char buf[20]; scanf(\"%19s\", buf); // No & needed, size limits input","title":"Strings"},{"location":"midterm/#static-vs-automatic-arrays","text":"Static Array : Single instance, persists entire program, initialized to 0. Automatic Array : New instance per function call, contains garbage unless initialized. static int s_arr[3]; // Persists, 0-initialized int a_arr[3]; // New each call, garbage values","title":"Static vs Automatic Arrays"},{"location":"midterm/#passing-an-array-to-a-function","text":"When passing an array to a function, we need to also supply the size of the array: void myFunc(int myArr[], size_t size); Alternatively we can use pointer syntax: void myFunc(int *myArr, size_t size); When calling the function, simply pass the array name (no brackets [] , no * ): myFunc(myArr, size) This passes a pointer to the first element of the array. The function can modify the original array (similar to pass by reference). If we do not want the function to be able to modify the array (e.g. for searching/reading), we can pass it as const to the function: void searchArray(const int arr[], size_t size); Note: If we pass an individual element of the array, such as myArr[3] that is passed by value and because of this it does not modify the original array.","title":"Passing an Array to a Function"},{"location":"midterm/#multi-dimensional-arrays","text":"Arrays of arrays (e.g., 2D array like a spreadsheet). First index is row, second is column (e.g., arr[row][col] ). Stored in row-major order (row by row) in contiguous 1D memory. Initializer Lists : int arr[3][3] = {{0, 1, 2}, {3, 4, 5}, {6, 7, 8}}; // Readable int arr[3][3] = {0, 1, 2, 3, 4, 5, 6, 7, 8}; // Same memory layout Passing to Functions : You must specify all dimension sizes except first (e.g., void printArray(int arr[][3], size_t nRows) ). Looping : Use descriptive indices (e.g., row , col ) instead of i , j . for (size_t row = 0; row < 3; ++row) { for (size_t col = 0; col < 3; ++col) { printf(\"%d \", arr[row][col]); } printf(\"\\n\"); }","title":"Multi-Dimensional Arrays"},{"location":"midterm/#variable-length-arrays-vlas","text":"Arrays sized at runtime (e.g., int arr[size] where size is user input). Bob says do not use in this course.","title":"Variable-Length Arrays (VLAs)"},{"location":"midterm/#functions-to-be-able-to-create-from-weeks-5-and-6","text":"Find max value in array int arr_max(const int a[], size_t n) { int max = a[0]; for (unsigned int i = 1; i < n; ++i) { if (a[i] > max) { max = a[i]; } } return max; } Index of first max value size_t arr_index_of_first_max(const int a[], size_t n) { int max = a[0]; int index = 0; for (unsigned int i = 1; i < n; ++i) { if (a[i] > max) { max = a[i]; index = i; } } return index; } Index of last max value size_t arr_index_of_last_max(const int a[], size_t n) { int max = a[0]; int index = 0; for (unsigned int i = 1; i < n; ++i) { if (a[i] >= max) { max = a[i]; index = i; } } return index; } Index of first occurrence of value int arr_index_of_value_first(const int a[], size_t n, int value) { for (unsigned int i = 0; i < n; ++i) { if (a[i] == value) { return i; } } return -1; } Index of last occurrence of value int arr_index_of_value_last(const int a[], size_t n, int value) { int index = -1; for (unsigned int i = 0; i < n; ++i) { if (a[i] == value) { index = i; } } return index; } Compare two arrays int arr_compare(const int a[], const int b[], size_t n) { for (unsigned int i = 0; i < n; ++i) { if (a[i] != b[i]) { return 0; } } return 1; } Find first occurrence of char int find_first(const char s[], char c) { for (int i = 0; s[i] != '\\0'; ++i) { if (s[i] == c) { return i; } } return -1; } Replace last occurrence of char int replace_last(char s[], char oldChar, char newChar) { int index = -1; for (int i = 0; s[i] != '\\0'; ++i) { if (s[i] == oldChar) { index = i; } } if (index != -1) { s[index] = newChar; } return index; } Count number of occurrences of char int count_occ(const char s[], char c) { int count = 0; for (int i = 0; s[i] != '\\0'; ++i) { if (s[i] == c) { ++count; } } return count; } Count alphabetic characters int count_alpha(const char s[]) { int count = 0; for (int i = 0; s[i] != '\\0'; ++i) { if (isalpha(s[i])) { ++count; } } return count; } Check if string is all digits int is_all_digits(const char s[]) { for (int i = 0; s[i] != '\\0'; ++i) { if (!isdigit(s[i])) { return 0; } } return 1; } Copy string to lowercase void lowercase_copy(char dest[], const char src[]) { int i; for (i = 0; src[i] != '\\0'; ++i) { dest[i] = tolower(src[i]); } dest[i] = '\\0'; } Validate BCIT ID int is_valid_bcit_id(const char id[]) { if (id[0] != 'a' && id[0] != 'A') { return 0; } int i; for (i = 1; (id[i] != '\\0') && (i < 10); ++i) { if (!isdigit(id[i])) { return 0; } } if (i != 9) { return 0; } return 1; } Return first word void return_first_word(const char input[], char output[]) { while ((*input != '\\0') && (isspace(*input))) { ++input; } while ((*input != '\\0') && (!isspace(*input))) { *output++ = *input++; } *output = '\\0'; } Return second word void return_second_word(const char input[], char output[]) { while ((*input != '\\0') && (isspace(*input))) { ++input; } while ((*input != '\\0') && (!isspace(*input))) { ++input; } while ((*input != '\\0') && (isspace(*input))) { ++input; } while ((*input != '\\0') && (!isspace(*input))) { *output++ = *input++; } *output = '\\0'; } Count number of words int return_count_of_words(const char input[]) { int count = 0; while ((*input != '\\0') && (isspace(*input))) { ++input; } while (*input != '\\0') { ++count; while ((*input != '\\0') && (!isspace(*input))) { ++input; } while ((*input != '\\0') && (isspace(*input))) { ++input; } } return count; } Return nth word void return_nth_word(const char input[], char output[], int n) { while ((*input != '\\0') && (isspace(*input))) { ++input; } int count = 1; while ((*input != '\\0') && (count < n)) { while ((*input != '\\0') && (!isspace(*input))) { ++input; } while ((*input != '\\0') && (isspace(*input))) { ++input; } ++count; } while ((*input != '\\0') && (!isspace(*input))) { *output++ = *input++; } *output = '\\0'; }","title":"Functions to be able to create from Weeks 5 and 6"},{"location":"wk_eight/","text":"Week 8 Pointers Pointers are simply variables whose values are memory addresses. Why Use Pointers? Because C uses pass-by-value , variables are normally copied when passed to functions which means changes inside the function don\u2019t affect the original variable. This is different from languages like Python or Java, where what you pass to a function is often a reference to an object , so changes inside the function can affect the original data (unless it\u2019s an immutable type). Without pointers, the only way to share or modify a variable between functions in C would be to make it global , which clutters your program and can lead to bugs and maintenance headaches. Pointers solve this by letting you indirectly access the memory by passing a reference (the actual memory address) instead of a copy. Indirection Referencing a value through a pointer is called indirection because we are using the address to find the value rather than directly accessing the value. When you use a pointer, you are telling the program where to look in memory to find the actual data. This lets different parts of a program safely share and update the same piece of data without needing global variables. More on Indirection To understand this concept lets imagine a block of memory as follows: +-----------+ | ??? | <- Address 0x1000 +-----------+ | ??? | <- Address 0x1004 +-----------+ | ??? | <- Address 0x1008 +-----------+ | ??? | <- Address 0x100C +-----------+ Note: In the above, `???` represents unallocated or unknown memory values. Memory addresses (e.g., `0x1000`, `0x1004`) are arbitrary and simplified for illustration, and assume 4-byte alignment typical for 32-bit systems. Suppose we create a variable count and assign it the value of 7. int count = 7; The program updates memory to place the value 7 at the first available address. +-----------+ | 7 | <- Address 0x1000 (count) +-----------+ | ??? | <- Address 0x1004 +-----------+ | ??? | <- Address 0x1008 +-----------+ | ??? | <- Address 0x100C +-----------+ Later we create a pointer to that memory. int *countPtr = &count; Our memory would now look something like this. +-----------+ | 7 | <- Address 0x1000 (count) +-----------+ | ??? | <- Address 0x1004 +-----------+ | ??? | <- Address 0x1008 +-----------+ | 0x1000 | <- Address 0x100C (countPtr) +-----------+ The variable countPtr holds the value 0x1000 which is the address of count. The original variable, count directly references the value 7 . countPtr on the other hand, indirectly references 7 . It tells you where to find the variable that holds the value 7 . Pointers Primer (video) Before we get deeper into pointer details, here\u2019s a quick video that explains the basics that was shared by a classmate ( SpaceBoy22 ) in our class Discord: Bro Code \u2014 C Programming Tutorial for Beginners 37 \u2014 Pointers Pointer Size A pointer is the size of the typical CPU register width in your system. For an x86 system, pointers are generally 32-bits wide (4 bytes). For an x64 computer, pointers are generally 64-bits wide (8 bytes) unless you are running a 32-bit version of an app (which will use 32-bit pointers). A bit is just a single 1 or 0 \u2014 so when we say \u201c32 bits\u201d or \u201c64 bits,\u201d we mean a chunk of 1s and 0s stored together. Larger pointers (64-bit) allow addressing more memory, up to 16 exabytes theoretically, compared to 4 GB for 32-bit pointers. More on registers A register is a tiny, extremely fast storage location built right into the CPU. On modern 64-bit CPUs, each register holds exactly 64 bits (8 bytes). The CPU uses these registers to: Hold operands for ALU operations (arithmetic, bitwise/logical, comparison & conditionals, etc.) Store intermediate results Keep track of instruction pointers and flags Behind the scenes, the ALU takes inputs from CPU registers, performs one of its many operations on those values in a single clock cycle, then writes the result (and status flags like zero or carry) back into registers. Because pointers need to reference any addressable location in memory, their size matches the register width. On a 32-bit system you get 32-bit (4 byte) pointers; on a 64-bit system you get 64-bit (8 byte) pointers \u2014 unless you\u2019re running a 32-bit app on a 64-bit system, which will still use 32-bit pointers. Declaring a Pointer To distinguish between a pointer and a regular variable, we use * to indicate to the compiler that the variable is a pointer. int *countPtr; This is read as \"countPtr is a pointer to an int\". It can be helpful to name a pointer in a way that makes it clear it is a pointer to the programmer such as ending the variable name with Ptr . Note: Pointer Declaration Syntax Variations There are several valid ways to write a pointer declaration, depending on where you place the * : int *countPtr; // * touches the name, emphasizing the name is a pointer int* countPtr; // * touches the type, emphasizing the pointer type int * countPtr; // * is between type and name, neutral style All three are equivalent to the compiler, as whitespace around * is ignored. However, the choice of style often depends on team coding standards or personal preference. For example, int* countPtr; highlights that the type is a pointer-to-int. Whereas int *countPtr; emphasizes that *countPtr is the pointer variable. Be cautious when declaring multiple variables in a single line, as the * placement can lead to confusion (see below). Note: Avoiding Ambiguity in Pointer Declarations When declaring multiple variables, it\u2019s best to split them over multiple lines. For example, consider the following code, which creates one pointer and one regular variable: int *countPtr, count; This can be ambiguous, especially with the alternate syntax: int* countPtr, count; Or: int * countPtr, count; This can make it look like both variables are pointers. To avoid ambiguity, split declarations over multiple lines: int* countPtr; int count; Initializing a Pointer When we define a pointer we should always initialize it with some value, even if that value is NULL . int *countPtr = NULL; Note we can also use 0 in place of NULL since NULL refers to address 0 . int *countPtr = 0; However, in practice it is best to be explicit about it being NULL . The Address ( & ) Operator The unary address operator & returns the address of its operand. int y = 5; int *yPtr = &y; We use the &y to assign the address of y to yPtr . The Indirection/Dereferencing ( * ) Operator The dereferencing operator * allows us to follow a pointer to access the value that it points to. printf(\"%d\", *yPtr); // prints 5 Dereferencing an uninitialized or NULL pointer (e.g., int *ptr; printf(\"%d\", *ptr); ) causes undefined behavior , often leading to program crashes. Always ensure a pointer points to a valid memory address before dereferencing. Note: Dual Meanings of * In C * has different meanings depending on context: In a declaration , it means the variable is a pointer to the given type. In an expression , it means dereference the pointer (access the value at the address). int x = 10; int *ptr = &x; // * in declaration: ptr is a pointer printf(\"%d\", *ptr); // * in expression: dereference to get 10 const with Pointers You will be tested on this! const can be used in two ways with pointers in a function: The first const means you cannot change the value being pointed to ( *dPtr is read-only). The second const means you cannot change the pointer itself (you can\u2019t make dPtr point somewhere else). Bob recommended remembering it this way: if const is beside the type it affects the data therefore you can't change the data that the pointer dereferences. if const is beside the pointer it affects the pointer therefore you can't make this pointer point to a different address. Note: This second const must come after the * but before the variable name. Writing const double const *dPtr , where the second const is before the * is not equivalent to the original example; both uses of const in this version apply to the data and not to the pointer. Incrementing a Pointer If you increment a pointer ( ++myPtr ), it simply moves to the next address in memory for that type \u2014 so it now points to the \u201cnext\u201d item. If you increment a pointer inside a function , only the local copy is changed. The original pointer in the caller still points to the same place unless you pass a pointer-to-pointer. This means that inside a function, you can use ++ or -- to loop through the memory next to the pointer without losing the original starting point .","title":"Week 8 - Pointer Introduction"},{"location":"wk_eight/#week-8","text":"","title":"Week 8"},{"location":"wk_eight/#pointers","text":"Pointers are simply variables whose values are memory addresses.","title":"Pointers"},{"location":"wk_eight/#why-use-pointers","text":"Because C uses pass-by-value , variables are normally copied when passed to functions which means changes inside the function don\u2019t affect the original variable. This is different from languages like Python or Java, where what you pass to a function is often a reference to an object , so changes inside the function can affect the original data (unless it\u2019s an immutable type). Without pointers, the only way to share or modify a variable between functions in C would be to make it global , which clutters your program and can lead to bugs and maintenance headaches. Pointers solve this by letting you indirectly access the memory by passing a reference (the actual memory address) instead of a copy.","title":"Why Use Pointers?"},{"location":"wk_eight/#indirection","text":"Referencing a value through a pointer is called indirection because we are using the address to find the value rather than directly accessing the value. When you use a pointer, you are telling the program where to look in memory to find the actual data. This lets different parts of a program safely share and update the same piece of data without needing global variables. More on Indirection To understand this concept lets imagine a block of memory as follows: +-----------+ | ??? | <- Address 0x1000 +-----------+ | ??? | <- Address 0x1004 +-----------+ | ??? | <- Address 0x1008 +-----------+ | ??? | <- Address 0x100C +-----------+ Note: In the above, `???` represents unallocated or unknown memory values. Memory addresses (e.g., `0x1000`, `0x1004`) are arbitrary and simplified for illustration, and assume 4-byte alignment typical for 32-bit systems. Suppose we create a variable count and assign it the value of 7. int count = 7; The program updates memory to place the value 7 at the first available address. +-----------+ | 7 | <- Address 0x1000 (count) +-----------+ | ??? | <- Address 0x1004 +-----------+ | ??? | <- Address 0x1008 +-----------+ | ??? | <- Address 0x100C +-----------+ Later we create a pointer to that memory. int *countPtr = &count; Our memory would now look something like this. +-----------+ | 7 | <- Address 0x1000 (count) +-----------+ | ??? | <- Address 0x1004 +-----------+ | ??? | <- Address 0x1008 +-----------+ | 0x1000 | <- Address 0x100C (countPtr) +-----------+ The variable countPtr holds the value 0x1000 which is the address of count. The original variable, count directly references the value 7 . countPtr on the other hand, indirectly references 7 . It tells you where to find the variable that holds the value 7 .","title":"Indirection"},{"location":"wk_eight/#pointers-primer-video","text":"Before we get deeper into pointer details, here\u2019s a quick video that explains the basics that was shared by a classmate ( SpaceBoy22 ) in our class Discord: Bro Code \u2014 C Programming Tutorial for Beginners 37 \u2014 Pointers","title":"Pointers Primer (video)"},{"location":"wk_eight/#pointer-size","text":"A pointer is the size of the typical CPU register width in your system. For an x86 system, pointers are generally 32-bits wide (4 bytes). For an x64 computer, pointers are generally 64-bits wide (8 bytes) unless you are running a 32-bit version of an app (which will use 32-bit pointers). A bit is just a single 1 or 0 \u2014 so when we say \u201c32 bits\u201d or \u201c64 bits,\u201d we mean a chunk of 1s and 0s stored together. Larger pointers (64-bit) allow addressing more memory, up to 16 exabytes theoretically, compared to 4 GB for 32-bit pointers. More on registers A register is a tiny, extremely fast storage location built right into the CPU. On modern 64-bit CPUs, each register holds exactly 64 bits (8 bytes). The CPU uses these registers to: Hold operands for ALU operations (arithmetic, bitwise/logical, comparison & conditionals, etc.) Store intermediate results Keep track of instruction pointers and flags Behind the scenes, the ALU takes inputs from CPU registers, performs one of its many operations on those values in a single clock cycle, then writes the result (and status flags like zero or carry) back into registers. Because pointers need to reference any addressable location in memory, their size matches the register width. On a 32-bit system you get 32-bit (4 byte) pointers; on a 64-bit system you get 64-bit (8 byte) pointers \u2014 unless you\u2019re running a 32-bit app on a 64-bit system, which will still use 32-bit pointers.","title":"Pointer Size"},{"location":"wk_eight/#declaring-a-pointer","text":"To distinguish between a pointer and a regular variable, we use * to indicate to the compiler that the variable is a pointer. int *countPtr; This is read as \"countPtr is a pointer to an int\". It can be helpful to name a pointer in a way that makes it clear it is a pointer to the programmer such as ending the variable name with Ptr .","title":"Declaring a Pointer"},{"location":"wk_eight/#note-pointer-declaration-syntax-variations","text":"There are several valid ways to write a pointer declaration, depending on where you place the * : int *countPtr; // * touches the name, emphasizing the name is a pointer int* countPtr; // * touches the type, emphasizing the pointer type int * countPtr; // * is between type and name, neutral style All three are equivalent to the compiler, as whitespace around * is ignored. However, the choice of style often depends on team coding standards or personal preference. For example, int* countPtr; highlights that the type is a pointer-to-int. Whereas int *countPtr; emphasizes that *countPtr is the pointer variable. Be cautious when declaring multiple variables in a single line, as the * placement can lead to confusion (see below).","title":"Note: Pointer Declaration Syntax Variations"},{"location":"wk_eight/#note-avoiding-ambiguity-in-pointer-declarations","text":"When declaring multiple variables, it\u2019s best to split them over multiple lines. For example, consider the following code, which creates one pointer and one regular variable: int *countPtr, count; This can be ambiguous, especially with the alternate syntax: int* countPtr, count; Or: int * countPtr, count; This can make it look like both variables are pointers. To avoid ambiguity, split declarations over multiple lines: int* countPtr; int count;","title":"Note: Avoiding Ambiguity in Pointer Declarations"},{"location":"wk_eight/#initializing-a-pointer","text":"When we define a pointer we should always initialize it with some value, even if that value is NULL . int *countPtr = NULL; Note we can also use 0 in place of NULL since NULL refers to address 0 . int *countPtr = 0; However, in practice it is best to be explicit about it being NULL .","title":"Initializing a Pointer"},{"location":"wk_eight/#the-address-operator","text":"The unary address operator & returns the address of its operand. int y = 5; int *yPtr = &y; We use the &y to assign the address of y to yPtr .","title":"The Address (&amp;) Operator"},{"location":"wk_eight/#the-indirectiondereferencing-operator","text":"The dereferencing operator * allows us to follow a pointer to access the value that it points to. printf(\"%d\", *yPtr); // prints 5 Dereferencing an uninitialized or NULL pointer (e.g., int *ptr; printf(\"%d\", *ptr); ) causes undefined behavior , often leading to program crashes. Always ensure a pointer points to a valid memory address before dereferencing.","title":"The Indirection/Dereferencing (*) Operator"},{"location":"wk_eight/#note-dual-meanings-of","text":"In C * has different meanings depending on context: In a declaration , it means the variable is a pointer to the given type. In an expression , it means dereference the pointer (access the value at the address). int x = 10; int *ptr = &x; // * in declaration: ptr is a pointer printf(\"%d\", *ptr); // * in expression: dereference to get 10","title":"Note: Dual Meanings of *"},{"location":"wk_eight/#const-with-pointers","text":"You will be tested on this! const can be used in two ways with pointers in a function: The first const means you cannot change the value being pointed to ( *dPtr is read-only). The second const means you cannot change the pointer itself (you can\u2019t make dPtr point somewhere else). Bob recommended remembering it this way: if const is beside the type it affects the data therefore you can't change the data that the pointer dereferences. if const is beside the pointer it affects the pointer therefore you can't make this pointer point to a different address. Note: This second const must come after the * but before the variable name. Writing const double const *dPtr , where the second const is before the * is not equivalent to the original example; both uses of const in this version apply to the data and not to the pointer.","title":"const with Pointers"},{"location":"wk_eight/#incrementing-a-pointer","text":"If you increment a pointer ( ++myPtr ), it simply moves to the next address in memory for that type \u2014 so it now points to the \u201cnext\u201d item. If you increment a pointer inside a function , only the local copy is changed. The original pointer in the caller still points to the same place unless you pass a pointer-to-pointer. This means that inside a function, you can use ++ or -- to loop through the memory next to the pointer without losing the original starting point .","title":"Incrementing a Pointer"},{"location":"wk_eleven/","text":"Week 11 This week continued where week 10 left off and continues looking at helpful string functions in different libraries. Input/Output Functions ( <stdio.h> ) getchar(void) Returns the next character from standard input as an int . putchar(int c) Prints the character represented by c . puts(const char *s) Prints the string s followed by a newline. sprintf(char *s, const char *format, ...) Exactly like printf but instead of printing to stdout it prints to a string variable. sscanf(char *s, const char *format, ...) Parses data from the string s , similarly to how scanf reads from input. fgets(char *s, int n, FILE *stream) Reads up to n-1 characters from stream into s , stopping at newline or EOF. Adds a null terminator. Newline is included if read. You can pass stdin as the stream argument to fgets , allowing it to read from standard input (i.e., the keyboard). This makes it a safer and more flexible alternative to scanf , especially when reading full lines of input. Unlike scanf , which stops at the first space and can leave unread characters in the input buffer, fgets reads the entire line up to the newline character, including spaces. When combined with sscanf , you can safely read and validate user input without risking buffer overflows or leftover input disrupting future reads. #include <stdio.h> int main() { char buffer[100]; int value; printf(\"Enter an integer: \"); if (fgets(buffer, sizeof(buffer), stdin)) { // reads entire line from stdin (leaving std in clean) if (sscanf(buffer, \"%d\", &value) == 1) { printf(\"You entered: %d\\n\", value); } else { printf(\"Invalid input! Please enter a number.\\n\"); } } return 0; } String-Manipulation Functions ( <string.h> ) The string-handling library provides useful functions for dealing with strings Manipulating string data Most functions automatically append the null terminator ( \\0 ) to the result. Exception: strncpy only does so if space permits. strcpy(char *s1, const char *s2) Copies s2 into s1 , including the null terminator. Returns a pointer to s1, which allows cascading (passing the result to another function) e.g., printf(\"%s\", strcpy(...)) . strncpy(char *s1, const char *s2, size_t n) Copies at most n characters from s2 into s1 . Null-terminates only if s2 fits. After using you should probably always do s1[n-1] = '\\0' to make sure that the NUL is there. strcat(char *s1, const char *s2) Appends s2 to the end of s1 , overwriting s1 's null terminator. strncat(char *s1, const char *s2, size_t n) Appends up to n characters of s2 to s1 . Comparing strings These functions compare two strings lexicographically (i.e., based on character order in the ASCII table). They return: 0 if the strings are equal a negative value if the first string is less than the second a positive value if the first string is greater than the second strcmp(const char *s1, const char *s2) Compares entire contents of s1 and s2 and then returns the result. strncmp(const char *s1, const char *s2, size_t n) Same as strcmp , but compares up to n characters. Searching within strings strchr(const char *s, int c) Finds the first occurrence of c in s . strrchr(const char *s, int c) Finds the last occurrence of c in s . strpbrk(const char *s1, const char *s2) Finds the first occurrence in s1 of any character from s2 . pbrk is short for point er to break (vaya con dios). strstr(const char *s1, const char *s2) Finds the first occurrence of the substring s2 in s1 . strspn(const char *s1, const char *s2) Returns the length of the initial segment of s1 containing only characters from s2 . spn is short for span. strcspn(const char *s1, const char *s2) Returns the length of the initial segment of s1 that does not contain any characters from s2 . cspn is short for complement span. Tokenizing strings (splitting them into pieces) strtok(char *s1, const char *s2) Splits s1 into tokens using characters in s2 as delimiters. Modifies s1 by inserting \\0 . Uses static memory to remember the current position. *strtok modifies the string by placing a \\0 after the first token. Therefore we should make a copy of the string if we intend to use it after calling strtok . It is stateful , meaning that it uses internal static storage to remember where it left off by saving a pointer to the byte following the one it just replaced by \\0 . After the first call to *strtok we need to pass NULL to continue tokenizing the same string (it will then use the static memory to find where it left off). If the byte it returns to is one of the separators, it will skip ahead to the next non-separator before continuing. If we pass a new string to *strtok it will reset the internal static storage which will effectively start a new sequence. Memory Functions These functions manipulate, compare, or search raw memory, not just null-terminated strings. They work on void * pointers and use an explicit byte count ( size_t n ), which means they: Do not check for null terminators Work with any data, not just strings Since void * can\u2019t be dereferenced, you must always pass the number of bytes explicitly. Note: Because these functions use size_t n to specify how many bytes to process, you should typically use sizeof(type) multiplied by the number of elements to make sure you return the correct number of elements. memcpy(void *s1, const void *s2, size_t n) Copies n bytes from s2 to s1 . Does not handle overlaps. According to Bob \"pros use this\". Its main advantage is that, rather than copying byte-by-byte, it will copy data in large chunks (such as 4, 8, or even 16\u201364 bytes at a time), often using SIMD instructions or wide registers where supported by the architecture. If the number of remaining bytes is smaller than the chunk size, memcpy will fall back to copying those tail bytes one at a time (or in smaller groups like 2 or 4 bytes), depending on alignment and platform optimizations. memmove(void *s1, const void *s2, size_t n) Safely copies n bytes from s2 to s1 , handling overlaps. Unlike memcpy , memmove guarantees that the copy will work even if s1 and s2 refer to parts of the same buffer. Use memmove when the source and destination may overlap, such as when: You're shifting elements within an array One pointer is a subregion (subscript) of the other memcmp(const void *s1, const void *s2, size_t n) Compares n bytes from two memory regions. Returns 0 if equal, <0 if s1 < s2 , >0 if s1 > s2 . memchr(const void *s, int c, size_t n) Searches the first n bytes of s for c . Returns a pointer to the match or NULL . memset(void *s, int c, size_t n) Fills the first n bytes of s with byte value c . Bob says \"pros\" also use this.. Measuring String Length strlen(const char *s) Returns a size_t representing the length of string s , excluding the null terminator ( \\0 ).","title":"Week 11 - More String Functions"},{"location":"wk_eleven/#week-11","text":"This week continued where week 10 left off and continues looking at helpful string functions in different libraries.","title":"Week 11"},{"location":"wk_eleven/#inputoutput-functions-stdioh","text":"","title":"Input/Output Functions (&lt;stdio.h&gt;)"},{"location":"wk_eleven/#getcharvoid","text":"Returns the next character from standard input as an int .","title":"getchar(void)"},{"location":"wk_eleven/#putcharint-c","text":"Prints the character represented by c .","title":"putchar(int c)"},{"location":"wk_eleven/#putsconst-char-s","text":"Prints the string s followed by a newline.","title":"puts(const char *s)"},{"location":"wk_eleven/#sprintfchar-s-const-char-format","text":"Exactly like printf but instead of printing to stdout it prints to a string variable.","title":"sprintf(char *s, const char *format, ...)"},{"location":"wk_eleven/#sscanfchar-s-const-char-format","text":"Parses data from the string s , similarly to how scanf reads from input.","title":"sscanf(char *s, const char *format, ...)"},{"location":"wk_eleven/#fgetschar-s-int-n-file-stream","text":"Reads up to n-1 characters from stream into s , stopping at newline or EOF. Adds a null terminator. Newline is included if read. You can pass stdin as the stream argument to fgets , allowing it to read from standard input (i.e., the keyboard). This makes it a safer and more flexible alternative to scanf , especially when reading full lines of input. Unlike scanf , which stops at the first space and can leave unread characters in the input buffer, fgets reads the entire line up to the newline character, including spaces. When combined with sscanf , you can safely read and validate user input without risking buffer overflows or leftover input disrupting future reads. #include <stdio.h> int main() { char buffer[100]; int value; printf(\"Enter an integer: \"); if (fgets(buffer, sizeof(buffer), stdin)) { // reads entire line from stdin (leaving std in clean) if (sscanf(buffer, \"%d\", &value) == 1) { printf(\"You entered: %d\\n\", value); } else { printf(\"Invalid input! Please enter a number.\\n\"); } } return 0; }","title":"fgets(char *s, int n, FILE *stream)"},{"location":"wk_eleven/#string-manipulation-functions-stringh","text":"The string-handling library provides useful functions for dealing with strings","title":"String-Manipulation Functions (&lt;string.h&gt;)"},{"location":"wk_eleven/#manipulating-string-data","text":"Most functions automatically append the null terminator ( \\0 ) to the result. Exception: strncpy only does so if space permits.","title":"Manipulating string data"},{"location":"wk_eleven/#strcpychar-s1-const-char-s2","text":"Copies s2 into s1 , including the null terminator. Returns a pointer to s1, which allows cascading (passing the result to another function) e.g., printf(\"%s\", strcpy(...)) .","title":"strcpy(char *s1, const char *s2)"},{"location":"wk_eleven/#strncpychar-s1-const-char-s2-size_t-n","text":"Copies at most n characters from s2 into s1 . Null-terminates only if s2 fits. After using you should probably always do s1[n-1] = '\\0' to make sure that the NUL is there.","title":"strncpy(char *s1, const char *s2, size_t n)"},{"location":"wk_eleven/#strcatchar-s1-const-char-s2","text":"Appends s2 to the end of s1 , overwriting s1 's null terminator.","title":"strcat(char *s1, const char *s2)"},{"location":"wk_eleven/#strncatchar-s1-const-char-s2-size_t-n","text":"Appends up to n characters of s2 to s1 .","title":"strncat(char *s1, const char *s2, size_t n)"},{"location":"wk_eleven/#comparing-strings","text":"These functions compare two strings lexicographically (i.e., based on character order in the ASCII table). They return: 0 if the strings are equal a negative value if the first string is less than the second a positive value if the first string is greater than the second","title":"Comparing strings"},{"location":"wk_eleven/#strcmpconst-char-s1-const-char-s2","text":"Compares entire contents of s1 and s2 and then returns the result.","title":"strcmp(const char *s1, const char *s2)"},{"location":"wk_eleven/#strncmpconst-char-s1-const-char-s2-size_t-n","text":"Same as strcmp , but compares up to n characters.","title":"strncmp(const char *s1, const char *s2, size_t n)"},{"location":"wk_eleven/#searching-within-strings","text":"","title":"Searching within strings"},{"location":"wk_eleven/#strchrconst-char-s-int-c","text":"Finds the first occurrence of c in s .","title":"strchr(const char *s, int c)"},{"location":"wk_eleven/#strrchrconst-char-s-int-c","text":"Finds the last occurrence of c in s .","title":"strrchr(const char *s, int c)"},{"location":"wk_eleven/#strpbrkconst-char-s1-const-char-s2","text":"Finds the first occurrence in s1 of any character from s2 . pbrk is short for point er to break (vaya con dios).","title":"strpbrk(const char *s1, const char *s2)"},{"location":"wk_eleven/#strstrconst-char-s1-const-char-s2","text":"Finds the first occurrence of the substring s2 in s1 .","title":"strstr(const char *s1, const char *s2)"},{"location":"wk_eleven/#strspnconst-char-s1-const-char-s2","text":"Returns the length of the initial segment of s1 containing only characters from s2 . spn is short for span.","title":"strspn(const char *s1, const char *s2)"},{"location":"wk_eleven/#strcspnconst-char-s1-const-char-s2","text":"Returns the length of the initial segment of s1 that does not contain any characters from s2 . cspn is short for complement span.","title":"strcspn(const char *s1, const char *s2)"},{"location":"wk_eleven/#tokenizing-strings-splitting-them-into-pieces","text":"","title":"Tokenizing strings (splitting them into pieces)"},{"location":"wk_eleven/#strtokchar-s1-const-char-s2","text":"Splits s1 into tokens using characters in s2 as delimiters. Modifies s1 by inserting \\0 . Uses static memory to remember the current position. *strtok modifies the string by placing a \\0 after the first token. Therefore we should make a copy of the string if we intend to use it after calling strtok . It is stateful , meaning that it uses internal static storage to remember where it left off by saving a pointer to the byte following the one it just replaced by \\0 . After the first call to *strtok we need to pass NULL to continue tokenizing the same string (it will then use the static memory to find where it left off). If the byte it returns to is one of the separators, it will skip ahead to the next non-separator before continuing. If we pass a new string to *strtok it will reset the internal static storage which will effectively start a new sequence.","title":"strtok(char *s1, const char *s2)"},{"location":"wk_eleven/#memory-functions","text":"These functions manipulate, compare, or search raw memory, not just null-terminated strings. They work on void * pointers and use an explicit byte count ( size_t n ), which means they: Do not check for null terminators Work with any data, not just strings Since void * can\u2019t be dereferenced, you must always pass the number of bytes explicitly. Note: Because these functions use size_t n to specify how many bytes to process, you should typically use sizeof(type) multiplied by the number of elements to make sure you return the correct number of elements.","title":"Memory Functions"},{"location":"wk_eleven/#memcpyvoid-s1-const-void-s2-size_t-n","text":"Copies n bytes from s2 to s1 . Does not handle overlaps. According to Bob \"pros use this\". Its main advantage is that, rather than copying byte-by-byte, it will copy data in large chunks (such as 4, 8, or even 16\u201364 bytes at a time), often using SIMD instructions or wide registers where supported by the architecture. If the number of remaining bytes is smaller than the chunk size, memcpy will fall back to copying those tail bytes one at a time (or in smaller groups like 2 or 4 bytes), depending on alignment and platform optimizations.","title":"memcpy(void *s1, const void *s2, size_t n)"},{"location":"wk_eleven/#memmovevoid-s1-const-void-s2-size_t-n","text":"Safely copies n bytes from s2 to s1 , handling overlaps. Unlike memcpy , memmove guarantees that the copy will work even if s1 and s2 refer to parts of the same buffer. Use memmove when the source and destination may overlap, such as when: You're shifting elements within an array One pointer is a subregion (subscript) of the other","title":"memmove(void *s1, const void *s2, size_t n)"},{"location":"wk_eleven/#memcmpconst-void-s1-const-void-s2-size_t-n","text":"Compares n bytes from two memory regions. Returns 0 if equal, <0 if s1 < s2 , >0 if s1 > s2 .","title":"memcmp(const void *s1, const void *s2, size_t n)"},{"location":"wk_eleven/#memchrconst-void-s-int-c-size_t-n","text":"Searches the first n bytes of s for c . Returns a pointer to the match or NULL .","title":"memchr(const void *s, int c, size_t n)"},{"location":"wk_eleven/#memsetvoid-s-int-c-size_t-n","text":"Fills the first n bytes of s with byte value c . Bob says \"pros\" also use this..","title":"memset(void *s, int c, size_t n)"},{"location":"wk_eleven/#measuring-string-length","text":"","title":"Measuring String Length"},{"location":"wk_eleven/#strlenconst-char-s","text":"Returns a size_t representing the length of string s , excluding the null terminator ( \\0 ).","title":"strlen(const char *s)"},{"location":"wk_five/","text":"Week 5 Arrays Arrays are data structures consisting of related data items of the same type. More specifically, an array is a group of elements of the same type stored contiguously in memory. Accessing Elements of an Array To access an element we specify the array name followed by a position number in [] . This position number is also known as a subscript or index . The index is 0-based so my_array[3] will be the fourth element of my_array . Defining an Array To define an array, we specify the type of the array followed by the number of elements that will be in the array in [] . For example, int my_arr[3]; will reserve a space that is 3 ints wide in memory and assign it the label my_arr. In C arrays are static entities meaning that they remain the same size throughout their lifetimes. That is, they can't be resized. Note: in general we should use a #define statement for the size of an array so that we can avoid using magic numbers Looping over an Array. When looping over an array, it is recommended to use a size_t type for the counter control variable. #include <stdio.h> int main(void) { for (size_t i = 0; i < 5; ++i) { n[i] = i; } } Initializer Lists We can define an array with an initializer list to set all the elements to specific values. int n[5] = {32, 27, 64, 18, 95} will set n[0] to 32, n[1] to 27, etc. The size of the initializer list does not need to be as large as the array. Any elements that are not specified will be set to 0. int n[5] = {0}; is equivalent to int n[5] = {0,0,0,0,0} . Strings A string in C is an array of char, terminated by a NUL character '\\0' (ASCII 0). As a side note - an array of char does not necessarily need to be a string but a string is always and array of char. There are a few ways to define a string: // 1. String literal \u2014 auto-size, NUL added char s1[] = \"hello\"; // 2. Fixed-size array with string literal \u2014 NUL added, extra space unused char s2[10] = \"hello\"; // 3. Character array with initializer list \u2014 must manually add '\\0' char s3[] = { 'h', 'e', 'l', 'l', 'o', '\\0' }; Note: for s2 style of defining a string, where we define the size we must always make sure that the size can accommodate the '\\0' at the end. char s2[5] = \"hello\" would be invalid because all 5 spaces would be used up. String Input When we want to grab input from the user, we can define a fixed size buffer array to store the string in and then use a size format specifier to make sure we do not exceed the size of the buffer. char buf[20]; scanf(\"%19s\", buf); // note that we don't add the & here that we // normally do in scanf because buf is an array // and is already a pointer Static vs Automatic Arrays Recall that static, similar to Java, means that something is only ever initialized once during a program call. Every time its referred to by a function thereafter, it refers to that single instance. This is in contrast to the default (automatic) array. Every time an automatic array initialized by a function it is a new instance of that array and is destroyed after we exit the function. static int s_arr[3]; // keeps values between calls - initialized to 0 by default int a_arr[3]; // new array each time \u2014 garbage values until initialized Type Lifetime Initialized to static array Entire program 0 (by default) automatic array Each function call Garbage (unless explicit)","title":"Week 5 - Arrays and Strings"},{"location":"wk_five/#week-5","text":"","title":"Week 5"},{"location":"wk_five/#arrays","text":"Arrays are data structures consisting of related data items of the same type. More specifically, an array is a group of elements of the same type stored contiguously in memory.","title":"Arrays"},{"location":"wk_five/#accessing-elements-of-an-array","text":"To access an element we specify the array name followed by a position number in [] . This position number is also known as a subscript or index . The index is 0-based so my_array[3] will be the fourth element of my_array .","title":"Accessing Elements of an Array"},{"location":"wk_five/#defining-an-array","text":"To define an array, we specify the type of the array followed by the number of elements that will be in the array in [] . For example, int my_arr[3]; will reserve a space that is 3 ints wide in memory and assign it the label my_arr. In C arrays are static entities meaning that they remain the same size throughout their lifetimes. That is, they can't be resized. Note: in general we should use a #define statement for the size of an array so that we can avoid using magic numbers","title":"Defining an Array"},{"location":"wk_five/#looping-over-an-array","text":"When looping over an array, it is recommended to use a size_t type for the counter control variable. #include <stdio.h> int main(void) { for (size_t i = 0; i < 5; ++i) { n[i] = i; } }","title":"Looping over an Array."},{"location":"wk_five/#initializer-lists","text":"We can define an array with an initializer list to set all the elements to specific values. int n[5] = {32, 27, 64, 18, 95} will set n[0] to 32, n[1] to 27, etc. The size of the initializer list does not need to be as large as the array. Any elements that are not specified will be set to 0. int n[5] = {0}; is equivalent to int n[5] = {0,0,0,0,0} .","title":"Initializer Lists"},{"location":"wk_five/#strings","text":"A string in C is an array of char, terminated by a NUL character '\\0' (ASCII 0). As a side note - an array of char does not necessarily need to be a string but a string is always and array of char. There are a few ways to define a string: // 1. String literal \u2014 auto-size, NUL added char s1[] = \"hello\"; // 2. Fixed-size array with string literal \u2014 NUL added, extra space unused char s2[10] = \"hello\"; // 3. Character array with initializer list \u2014 must manually add '\\0' char s3[] = { 'h', 'e', 'l', 'l', 'o', '\\0' }; Note: for s2 style of defining a string, where we define the size we must always make sure that the size can accommodate the '\\0' at the end. char s2[5] = \"hello\" would be invalid because all 5 spaces would be used up.","title":"Strings"},{"location":"wk_five/#string-input","text":"When we want to grab input from the user, we can define a fixed size buffer array to store the string in and then use a size format specifier to make sure we do not exceed the size of the buffer. char buf[20]; scanf(\"%19s\", buf); // note that we don't add the & here that we // normally do in scanf because buf is an array // and is already a pointer","title":"String Input"},{"location":"wk_five/#static-vs-automatic-arrays","text":"Recall that static, similar to Java, means that something is only ever initialized once during a program call. Every time its referred to by a function thereafter, it refers to that single instance. This is in contrast to the default (automatic) array. Every time an automatic array initialized by a function it is a new instance of that array and is destroyed after we exit the function. static int s_arr[3]; // keeps values between calls - initialized to 0 by default int a_arr[3]; // new array each time \u2014 garbage values until initialized Type Lifetime Initialized to static array Entire program 0 (by default) automatic array Each function call Garbage (unless explicit)","title":"Static vs Automatic Arrays"},{"location":"wk_four/","text":"Week 4 Enumerated Types Enumerated types are types created by the programmer themselves. They enumerate all the legal values that can be assigned to a variable of that type. enum DaysOfWeek {SUN, MON, TUES, WED, THU, FRI, SAT}; enum DaysOfWeek today = MON; // will assign 1 to today Example: Click to show code #include <stdio.h> enum DaysOfWeek { SUN, MON, TUES, WED, THU, FRI, SAT }; const char *day_name(enum DaysOfWeek day) { switch (day) { case SUN: return \"Sunday\"; case MON: return \"Monday\"; case TUES: return \"Tuesday\"; case WED: return \"Wednesday\"; case THU: return \"Thursday\"; case FRI: return \"Friday\"; case SAT: return \"Saturday\"; default: return \"Invalid\"; } } int main(void) { printf(\"All days of the week:\\n\"); for (enum DaysOfWeek d = SUN; d <= SAT; ++d) { printf(\"%d = %s\\n\", d, day_name(d)); } return 0; } By default, the first name is assigned the integer value 0, and each subsequent name increases by 1. We can also explicitly set values. enum Status {CONTINUE = 0, WON = 1, LOST = 2}; Storage Classes Variables have other attributes beside the name , type , size and value . One such is the storage class specifier which we will go into below. The storage class specifier is used to determine the following other attributes: storage duration (when it exists in memory), scope (where a program can reference the identifier), and linkage (whether it is known only in the current file or in any source) for the identifier. C has the following storage class specifiers : auto This is the default for local (block-scope) variables. It tells the compiler to store the variable in automatic storage (i.e., on the stack). It's largely redundant in modern C and rarely written explicitly. register This was used to request that a variable be stored in a CPU register for faster access. You cannot get the address of a register variable using & . Modern compilers ignore it and optimize register usage themselves, so this is now mostly obsolete. static Gives a variable static storage duration \u2013 it exists for the lifetime of the program, even if defined inside a function. Two main uses: Static local variables : retain their value between function calls. Static global variables/functions : restrict visibility to the current translation unit (file) \u2013 no external linkage. extern Tells the compiler that a global variable or function exists in another file. It does not create storage; it just declares the identifier so it can be used. Common use: declare a global variable defined in another .c file. Scope The scope of an identifier is the portion of the program in which that identifier can be referenced. In C there are four identifier scopes: function scope Applies only to labels (e.g., start: ) used with goto and switch statements. Labels are visible anywhere in the function where they're defined, but note outside it. They support information hiding, aligning with the principle of least privilege : only grant access needed for a specific task. file scope Applies to identifiers declared outside any function. Visibility spans from the point of declaration to the end of the file. Examples: Global variables Function prototypes Function definitions outside functions block scope Applies to identifiers declared inside a block (between { and } ). Blocks can nest , and inner blocks can hide outer block identifiers with the same name \u2014 generally best to avoid name hiding. static local variables still have block scope (but static storage duration). function-prototype scope Applies only to parameter names in function prototypes - within the () of a prototype These names are optional and ignored by the compiler \u2014 only types matter. Memory Regions Overview Before we move on, it's useful to understand where variables actually live in memory. The location affects how long they last, how they're accessed, and how they're cleaned up. Stack Static Heap Automatic Variables Global Variables Dynamic Variables* Static Local Variables *dynamic variables are created with malloc() , calloc() , and realloc() . Stack: Fast allocation/deallocation; tied to block scope. Stack variables are automatically deallocated when their scope ends. Static: Persistent for the program\u2019s lifetime; only initialized once. Heap: Used for dynamic memory; you manage it explicitly. The Heap vs. A Heap The term heap can refer to two separate concepts in programming \u2014 one related to memory, the other to data structures and algorithms. The heap (memory region): A section of memory used for dynamic allocation. Variables stored here persist until manually deallocated (e.g., with free() in C). No ordering \u2014 not FIFO, not LIFO. It's just a pool of memory. A heap (data structure): A type of tree-based structure (e.g., min-heap or max-heap) used for priority queues. Has ordering rules (e.g., smallest or largest item always on top), but unrelated to memory allocation.","title":"Week 4 - Enums, Storage Classes, and Memory Layout"},{"location":"wk_four/#week-4","text":"","title":"Week 4"},{"location":"wk_four/#enumerated-types","text":"Enumerated types are types created by the programmer themselves. They enumerate all the legal values that can be assigned to a variable of that type. enum DaysOfWeek {SUN, MON, TUES, WED, THU, FRI, SAT}; enum DaysOfWeek today = MON; // will assign 1 to today Example: Click to show code #include <stdio.h> enum DaysOfWeek { SUN, MON, TUES, WED, THU, FRI, SAT }; const char *day_name(enum DaysOfWeek day) { switch (day) { case SUN: return \"Sunday\"; case MON: return \"Monday\"; case TUES: return \"Tuesday\"; case WED: return \"Wednesday\"; case THU: return \"Thursday\"; case FRI: return \"Friday\"; case SAT: return \"Saturday\"; default: return \"Invalid\"; } } int main(void) { printf(\"All days of the week:\\n\"); for (enum DaysOfWeek d = SUN; d <= SAT; ++d) { printf(\"%d = %s\\n\", d, day_name(d)); } return 0; } By default, the first name is assigned the integer value 0, and each subsequent name increases by 1. We can also explicitly set values. enum Status {CONTINUE = 0, WON = 1, LOST = 2};","title":"Enumerated Types"},{"location":"wk_four/#storage-classes","text":"Variables have other attributes beside the name , type , size and value . One such is the storage class specifier which we will go into below. The storage class specifier is used to determine the following other attributes: storage duration (when it exists in memory), scope (where a program can reference the identifier), and linkage (whether it is known only in the current file or in any source) for the identifier. C has the following storage class specifiers : auto This is the default for local (block-scope) variables. It tells the compiler to store the variable in automatic storage (i.e., on the stack). It's largely redundant in modern C and rarely written explicitly. register This was used to request that a variable be stored in a CPU register for faster access. You cannot get the address of a register variable using & . Modern compilers ignore it and optimize register usage themselves, so this is now mostly obsolete. static Gives a variable static storage duration \u2013 it exists for the lifetime of the program, even if defined inside a function. Two main uses: Static local variables : retain their value between function calls. Static global variables/functions : restrict visibility to the current translation unit (file) \u2013 no external linkage. extern Tells the compiler that a global variable or function exists in another file. It does not create storage; it just declares the identifier so it can be used. Common use: declare a global variable defined in another .c file.","title":"Storage Classes"},{"location":"wk_four/#scope","text":"The scope of an identifier is the portion of the program in which that identifier can be referenced. In C there are four identifier scopes: function scope Applies only to labels (e.g., start: ) used with goto and switch statements. Labels are visible anywhere in the function where they're defined, but note outside it. They support information hiding, aligning with the principle of least privilege : only grant access needed for a specific task. file scope Applies to identifiers declared outside any function. Visibility spans from the point of declaration to the end of the file. Examples: Global variables Function prototypes Function definitions outside functions block scope Applies to identifiers declared inside a block (between { and } ). Blocks can nest , and inner blocks can hide outer block identifiers with the same name \u2014 generally best to avoid name hiding. static local variables still have block scope (but static storage duration). function-prototype scope Applies only to parameter names in function prototypes - within the () of a prototype These names are optional and ignored by the compiler \u2014 only types matter.","title":"Scope"},{"location":"wk_four/#memory-regions-overview","text":"Before we move on, it's useful to understand where variables actually live in memory. The location affects how long they last, how they're accessed, and how they're cleaned up. Stack Static Heap Automatic Variables Global Variables Dynamic Variables* Static Local Variables *dynamic variables are created with malloc() , calloc() , and realloc() . Stack: Fast allocation/deallocation; tied to block scope. Stack variables are automatically deallocated when their scope ends. Static: Persistent for the program\u2019s lifetime; only initialized once. Heap: Used for dynamic memory; you manage it explicitly.","title":"Memory Regions Overview"},{"location":"wk_four/#the-heap-vs-a-heap","text":"The term heap can refer to two separate concepts in programming \u2014 one related to memory, the other to data structures and algorithms.","title":"The Heap vs. A Heap"},{"location":"wk_four/#the-heap-memory-region","text":"A section of memory used for dynamic allocation. Variables stored here persist until manually deallocated (e.g., with free() in C). No ordering \u2014 not FIFO, not LIFO. It's just a pool of memory.","title":"The heap (memory region):"},{"location":"wk_four/#a-heap-data-structure","text":"A type of tree-based structure (e.g., min-heap or max-heap) used for priority queues. Has ordering rules (e.g., smallest or largest item always on top), but unrelated to memory allocation.","title":"A heap (data structure):"},{"location":"wk_nine/","text":"Week 9 The sizeof Operator C provides a unary (one-input) operator to determine an object's or type's size in bytes (Bob stresses that sizeof is not a function). It calculates the size of the object at compile time and not during runtime. It always returns the number of bytes as a size_t . When applied to arrays, sizeof will use the size of the underlying type times the number of elements to determine the overall size of the array. For example, int array[20]; printf(\"%zu\", sizeof array); will output 80 (4*20) where 4 is the size of an int and 20 is the number of elements in the array. Pointers and sizeof One thing to watch out for is applying sizeof to pointers. Even if the pointer is pointing to an array or some other type element, the sizeof operator will always return the size of the pointer in the system and not the size of the element it points to. Recall that pointers are determined by the size of a register in the underlying system / what the application expects the size of the register to be. In modern systems this will be either 64- or 32-bit (8- or 4-bytes respectively). This is especially important to remember when it comes to arrays. Remember that arrays decay to a pointer when they are passed to a function. In essence, once we are in the function, it only sees the pointer to the first element; the function will not know that the element pointed to is the start of an array. Sizes Caveat Remember that, while type sizes are mostly consistent, they can vary on different systems. We can verify the sizes in our given system by using sizeof on a type . When we do this, we must use parentheses () around the type: sizeof(int) . More on Pointers Pointer Arithmetic Operators Pointers are valid operands in arithmetic operations (however, not all arithmetic operators can be used with pointers). The following arithmetic operators are allowed with pointers: incrementing ++ and decrementing -- , adding an integer to a pointer + or += , subtracting an integer from a pointer - or -= , and subtracting one pointer from another (to tell how far apart they are). Aiming a Pointer at an Array We can point to an array as follows: int myArray[] = {0, 1, 2, 3, 4}; int *myPtr = myArray; // this will point to the first element of the array //alternatively we can do the following equivalent expression int *mySecondPtr = &myArray[0]; // go to myArray[0] and grab its address Adding (and subtracting) an Integer to (from) a Pointer When you add an integer to a pointer, the compiler uses the size of the type to calculate the new address in blocks, not raw bytes. For example, suppose you have a pointer int *myPtr pointing to address 0x1000 : +-----------+ | 0 | <- Address 0x1000 +-----------+ | 1 | <- Address 0x1004 +-----------+ | 2 | <- Address 0x1008 +-----------+ | 3 | <- Address 0x100C +-----------+ | 4 | <- Address 0x1010 +-----------+ If you added 2 to the raw address 0x1000 mathematically, you'd get 0x1002 . But when you write myPtr += 2 , the compiler treats this as \"move forward 2 ints,\" so it multiplies 2 by the size of an int (4 bytes). The result is 0x1000 + 8 = 0x1008 . The same rule applies when subtracting an integer: myPtr -= 1 moves the pointer back by the size of one element. This is also true for the increment ++ and decrement -- operators: myPtr++ moves to the next element, not just the next byte. Subtracting One Pointer from Another You can subtract one pointer from another to find how many elements apart they are. For example, suppose we have two pointers as follows: int *myPtr; // assume it points to 0x1000 int *myOtherPtr; // assume it points to 0x1008. These addresses are 8 bytes apart. Since each int is 4 bytes, myOtherPtr - myPtr we will get a result of 2. That is, these pointers are two elements apart. The compiler automatically divides the byte difference by the size of the type, so pointer subtraction always gives a count of elements , not raw bytes. Pointers to void Pointers of the same type can be assigned to each other directly. void * is a generic pointer type; any pointer can be assigned to a void * , and a void * can be assigned to any other pointer type without casting. You can\u2019t dereference a void * because the compiler doesn\u2019t know what type (and size) it points to. You must cast it to a specific pointer type first. Arrays, Pointers, and Offset Notation In C, an array name acts like a constant pointer to the array\u2019s first element. For example, b is equivalent to &b[0] . This lets you assign a pointer to the start of an array like bPtr = b; . Because of this, you can use pointer arithmetic instead of subscripts. For example: - b[3] is the same as *(b + 3) - *(bPtr + 3) is the same as bPtr[3] The number added is an offset , which moves the pointer forward by that many elements . Always use parentheses like *(b + 3) , because * has higher precedence than + . Without parentheses, *b + 3 means \"dereference b then add 3\" instead of \"move the pointer by 3 then dereference.\" In general, any array element access b[i] can be written using pointer/offset notation : *(b + i) . Pointers to Functions A function's name is really a pointer to the starting address in memmory of the code that makes up that function (similar to how an array's name is a pointer to the start of the array). We can pass the pointer to the function as follows: void bubbleSort(int work[], size_t size, int (*compare)(int a, int b)) Specifically, we are passing saying that (*compare) is a function that takes (int a, int b) as arguments and returns an int . Note: the brackets must be around *compare to indicate that it is a pointer to a function. Otherwise this would be declaring a function named compare that returns an int pointer. When we want to call the function, we need to derference it. (*compare)(5, 6);","title":"Week 9 - Pointer Arithmetic and sizeof Operator"},{"location":"wk_nine/#week-9","text":"","title":"Week 9"},{"location":"wk_nine/#the-sizeof-operator","text":"C provides a unary (one-input) operator to determine an object's or type's size in bytes (Bob stresses that sizeof is not a function). It calculates the size of the object at compile time and not during runtime. It always returns the number of bytes as a size_t . When applied to arrays, sizeof will use the size of the underlying type times the number of elements to determine the overall size of the array. For example, int array[20]; printf(\"%zu\", sizeof array); will output 80 (4*20) where 4 is the size of an int and 20 is the number of elements in the array.","title":"The sizeof Operator"},{"location":"wk_nine/#pointers-and-sizeof","text":"One thing to watch out for is applying sizeof to pointers. Even if the pointer is pointing to an array or some other type element, the sizeof operator will always return the size of the pointer in the system and not the size of the element it points to. Recall that pointers are determined by the size of a register in the underlying system / what the application expects the size of the register to be. In modern systems this will be either 64- or 32-bit (8- or 4-bytes respectively). This is especially important to remember when it comes to arrays. Remember that arrays decay to a pointer when they are passed to a function. In essence, once we are in the function, it only sees the pointer to the first element; the function will not know that the element pointed to is the start of an array.","title":"Pointers and sizeof"},{"location":"wk_nine/#sizes-caveat","text":"Remember that, while type sizes are mostly consistent, they can vary on different systems. We can verify the sizes in our given system by using sizeof on a type . When we do this, we must use parentheses () around the type: sizeof(int) .","title":"Sizes Caveat"},{"location":"wk_nine/#more-on-pointers","text":"","title":"More on Pointers"},{"location":"wk_nine/#pointer-arithmetic-operators","text":"Pointers are valid operands in arithmetic operations (however, not all arithmetic operators can be used with pointers). The following arithmetic operators are allowed with pointers: incrementing ++ and decrementing -- , adding an integer to a pointer + or += , subtracting an integer from a pointer - or -= , and subtracting one pointer from another (to tell how far apart they are).","title":"Pointer Arithmetic Operators"},{"location":"wk_nine/#aiming-a-pointer-at-an-array","text":"We can point to an array as follows: int myArray[] = {0, 1, 2, 3, 4}; int *myPtr = myArray; // this will point to the first element of the array //alternatively we can do the following equivalent expression int *mySecondPtr = &myArray[0]; // go to myArray[0] and grab its address","title":"Aiming a Pointer at an Array"},{"location":"wk_nine/#adding-and-subtracting-an-integer-to-from-a-pointer","text":"When you add an integer to a pointer, the compiler uses the size of the type to calculate the new address in blocks, not raw bytes. For example, suppose you have a pointer int *myPtr pointing to address 0x1000 : +-----------+ | 0 | <- Address 0x1000 +-----------+ | 1 | <- Address 0x1004 +-----------+ | 2 | <- Address 0x1008 +-----------+ | 3 | <- Address 0x100C +-----------+ | 4 | <- Address 0x1010 +-----------+ If you added 2 to the raw address 0x1000 mathematically, you'd get 0x1002 . But when you write myPtr += 2 , the compiler treats this as \"move forward 2 ints,\" so it multiplies 2 by the size of an int (4 bytes). The result is 0x1000 + 8 = 0x1008 . The same rule applies when subtracting an integer: myPtr -= 1 moves the pointer back by the size of one element. This is also true for the increment ++ and decrement -- operators: myPtr++ moves to the next element, not just the next byte.","title":"Adding (and subtracting) an Integer to (from) a Pointer"},{"location":"wk_nine/#subtracting-one-pointer-from-another","text":"You can subtract one pointer from another to find how many elements apart they are. For example, suppose we have two pointers as follows: int *myPtr; // assume it points to 0x1000 int *myOtherPtr; // assume it points to 0x1008. These addresses are 8 bytes apart. Since each int is 4 bytes, myOtherPtr - myPtr we will get a result of 2. That is, these pointers are two elements apart. The compiler automatically divides the byte difference by the size of the type, so pointer subtraction always gives a count of elements , not raw bytes.","title":"Subtracting One Pointer from Another"},{"location":"wk_nine/#pointers-to-void","text":"Pointers of the same type can be assigned to each other directly. void * is a generic pointer type; any pointer can be assigned to a void * , and a void * can be assigned to any other pointer type without casting. You can\u2019t dereference a void * because the compiler doesn\u2019t know what type (and size) it points to. You must cast it to a specific pointer type first.","title":"Pointers to void"},{"location":"wk_nine/#arrays-pointers-and-offset-notation","text":"In C, an array name acts like a constant pointer to the array\u2019s first element. For example, b is equivalent to &b[0] . This lets you assign a pointer to the start of an array like bPtr = b; . Because of this, you can use pointer arithmetic instead of subscripts. For example: - b[3] is the same as *(b + 3) - *(bPtr + 3) is the same as bPtr[3] The number added is an offset , which moves the pointer forward by that many elements . Always use parentheses like *(b + 3) , because * has higher precedence than + . Without parentheses, *b + 3 means \"dereference b then add 3\" instead of \"move the pointer by 3 then dereference.\" In general, any array element access b[i] can be written using pointer/offset notation : *(b + i) .","title":"Arrays, Pointers, and Offset Notation"},{"location":"wk_nine/#pointers-to-functions","text":"A function's name is really a pointer to the starting address in memmory of the code that makes up that function (similar to how an array's name is a pointer to the start of the array). We can pass the pointer to the function as follows: void bubbleSort(int work[], size_t size, int (*compare)(int a, int b)) Specifically, we are passing saying that (*compare) is a function that takes (int a, int b) as arguments and returns an int . Note: the brackets must be around *compare to indicate that it is a pointer to a function. Otherwise this would be declaring a function named compare that returns an int pointer. When we want to call the function, we need to derference it. (*compare)(5, 6);","title":"Pointers to Functions"},{"location":"wk_one/","text":"Week 1 Week 1 focused on the basics of C: what it is, how a C program is built and run, and how we interact with it using functions like main() , printf() , and scanf() . What is C C is a language evolved from BCPL and B language. It became popular on Unix systems which were among the first hardware agnostic OS. C is used for highly performant programs because it is quite efficient. C is widely used in operating systems (e.g., Linux kernel), embedded systems, and as a foundation for languages like C++ and Java. C does not have any objects. That means we only have functions to use to structure our programs. C Development There are typically six phases of a program in C: editing/programming preprocess These are commands that will change the code that you write examples are #include and #define back in the day, there were no mice to copy and paste things and the terminals were dumb (brains were in the mainframe) so it was difficult to copy and paste things. preprocessor allows you to do things similar to a copy and paste. for #include , think of it like copying and pasting the contents of the included file into this one. for #define , think of it like a text replacement in our code. compile catches syntax errors creates machine code from your code into .o files link combines the .o files and the C Library Object Code into an executable load The operating system loads the executable into memory, preparing it for execution. execute The CPU runs the program, starting from the main function. main Function In C programs begin execution in the main() function. The basic syntax is: int main(void) { // ... do stuff } In modern C (C99 and later), main() implicitly returns 0 if no return statement is given. This only applies to main() \u2014 all other functions require an explicit return if they are non-void. 0 indicates success 1 or any positive int up to 255 signifies an error. We can see the returned value in the terminal by typing: echo $? We can also take command line arguments in main with the following syntax: int main(int argc, char *argv[]) // OR int main(int argc char **argv) Example with CLI arguments In this example, we take in a command line argument along with the function call. The program ends by listing the argument index and the argument value to highlight that the first argument is always the name of the program: #include <stdio.h> // we need to include stdio to get access to puts() and printf() funtions. #include <stdlib.h> // for EXIT_FAILURE and EXIT_SUCCESS macros int main(int argc, char *argv[]) { if (argc != 2) { puts(\"Usage: ./hello_2 <input_name>\"); return EXIT_FAILURE; // EXIT_FAILURE evaluates to 1 and is more portable than hardcoding the value } printf(\"Hello, %s\\n\", argv[1]); puts(\"Welcome to COMP2701\\n\"); puts(\"Here are the arguments that were supplied:\"); for (int i = 0; i < argc; i++) { printf(\"%3d %10s\\n\", i, argv[i]); } puts(\"\"); return EXIT_SUCCESS;// EXIT_SUCCESS evaluates to 0 } Printing Output In C, functions like printf() and puts() are used to print output to the screen. Unlike Python or Java, these functions aren\u2019t available by default \u2014 you must include the appropriate header file first. For both printf() and puts() , that file is <stdio.h> (standard I/O). To use them, simply add #include <stdio.h> at the top of your program. puts() puts() prints out strictly a string of text. We can only pass string literals into puts() . puts() automatically appends a newline character to the end of the string. printf() printf() (or print f ormatted) prints out a formatted string where, like python and Java, we can pass in variables. Unlike puts() , printf() does not append a newline character. We must end the string with \\n if we want a new line. In order to use variables in a printf() statement, we must pass in a string with placeholder format specifiers followed by a list of the variables to place in the specifiers. int i = 10; printf(\"The value of i is %d.\\n\", i); // The value of i is 10. printf() Format Specifiers The following is a list of some common format specifiers: Specifier Description Example Output Data Type %d Signed decimal integer 42 int %i Signed decimal integer (same as %d ) 42 int %u Unsigned decimal integer 42 unsigned int %zu Unsigned size of objects in bytes 42 size_t %f Decimal floating point 3.141593 float , double %F Decimal floating point (uppercase INF/NAN ) 3.141593 float , double %c Single character A char %s String of characters Hello char * %p Pointer address 0x7ffeefbff5c0 void * %% Literal % character % \u2014 Getting User Input In C there are a few ways to get user input. For our purposes, we will be using scanf() in this course. As with the printing functions, scanf() is found in the <stdio.h> library so make sure to include that in programs that will use scanf() . int number = 0; printf(\"Please enter a number: \"); if (scanf(\"%d\", &number) != 1) { printf(\"Invalid input!\\n\"); return 1; } printf(\"You entered %d.\\n\", number); // Please enter a number: 10 // You entered 10. Unlike printf() and puts() , scanf() requires the address of variables (e.g., &number in the above example). This is because C passes variables by value, meaning a copy is passed unless the address is provided. Since scanf() is looking for a place to store the result, simply passing in the variable as usual would be pointless - we would be writing to a copy and not changing the result. Instead we give scanf() the address in memory where we would like to store the result. In practice, we generally want to prefix any variable that we are storing a result to with the address symbol & . The only time we don't need to do this is with arrays (which we will cover later in this course). Example of scanf() with an array: char name[20]; printf(\"Enter your name: \"); scanf(\"%19s\", name); // note: NO \"&\" here because a string is an array of chars. printf(\"Hello, %s!\\n\", name); scanf() Format Specifiers The next notable difference is that there are some slighlty different format specifiers in scanf() . Here is a summary of some of the main differences: Type printf scanf Why it matters double %f %lf Must use %lf in scanf float %f %f scanf(\"%f\") stores to float* only short %d %hd scanf needs h to downcast long %d or %ld %ld Same specifier, but required in scanf - printf can accept a long in %d but could overflow so not advised. long long %lld %lld Required for long long in both Other Gotchas In addition to needing addresses and the slightly different format specifiers, there are a few other behaviours worth noting. Character Input scanf(\"%c\", &ch) reads any character, including whitespace, which can cause issues due to leftover newlines in the input buffer. int x; char ch; scanf(\"%d\", &x); // user enters: 5\u23ce scanf(\"%c\", &ch); // reads \u23ce as the char! String Inputs scanf(\"%s\", str) reads input up to the first whitespace (space, tab, or newline). Because of this, using it without a width specifier is unsafe and risks a buffer overflow. In contrast, printf(\"%s\", str) will print the entire string until it sees the \\0 NUL character. char str[5]; scanf(\"%s\", str); // \u274c may overflow if input > 4 chars scanf(\"%4s\", str); // \u2705 safer (leaves 1 byte for '\\0') Note: What is a String in C? In C, a string is not a separate type \u2014 it's just an array of char values that ends with a NUL terminator ( '\\0' ). So when you write: char name[] = \"Alice\"; It\u2019s really just shorthand for: char name[] = { 'A', 'l', 'i', 'c', 'e', '\\0' }; That special '\\0' character tells functions like printf(\"%s\", name) where the string ends. Put another way, strings in C are really just arrays of characters with a rule: they must end in '\\0' . Unlike in Python, Java, or C++, there's no built-in \"string\" type \u2014 just arrays and pointers. Note: NUL vs NULL These look similar but serve very different purposes in C: Term Type Meaning NUL char ASCII character 0 (value 0x00 ) NULL pointer Null pointer constant (typically 0 or (void*)0 ) NUL ( '\\0' ) A character with value 0 Used to terminate C strings Equivalent to: char c = '\\0'; // or: char c = 0; NULL A macro that represents a null pointer constant Typically defined as ((void *)0) in <stddef.h> Used when a pointer doesn\u2019t point to a valid memory location. Example: int *ptr = NULL; if (ptr == NULL) { // pointer is uninitialized or empty } Note: What is a char in C? In C, a char is a fundamental data type that represents a single character, but at its core, it is simply an 8-bit integer (typically 1 byte) that can hold values from -128 to 127 (for signed char) or 0 to 255 (for unsigned char). These numeric values are often used to represent characters according to the ASCII table, where each number corresponds to a specific character. For example: The character 'A' has an ASCII value of 65. The character 'a' has an ASCII value of 97. The character '0' (the digit zero) has an ASCII value of 48. You can work with char values as either characters or numbers. For instance: char c = 'A'; // Stores the character 'A' (ASCII value 65) printf(\"%c\\n\", c); // Prints: A printf(\"%d\\n\", c); // Prints: 65 This dual nature of char allows you to perform arithmetic operations on characters. For example: char c = 'A'; c = c + 1; // Moves to the next ASCII value ('B' = 66) printf(\"%c\\n\", c); // Prints: B The ASCII table is critical for understanding how characters are represented in C. Common ASCII values include: Common ASCII Values Character ASCII Value Description 'A' 65 Uppercase A 'Z' 90 Uppercase Z 'a' 97 Lowercase a 'z' 122 Lowercase z '0' 48 Digit 0 '9' 57 Digit 9 ' ' 32 Space '\\n' 10 Newline '\\0' 0 NUL (string terminator) Lowercase and Uppercase letters are exactly 32 values away from the same letter When using char in strings or with input/output functions like printf() and scanf() , the ASCII encoding ensures that numeric values are interpreted as readable characters.","title":"Week 1 - Introduction to C & Data Types"},{"location":"wk_one/#week-1","text":"Week 1 focused on the basics of C: what it is, how a C program is built and run, and how we interact with it using functions like main() , printf() , and scanf() .","title":"Week 1"},{"location":"wk_one/#what-is-c","text":"C is a language evolved from BCPL and B language. It became popular on Unix systems which were among the first hardware agnostic OS. C is used for highly performant programs because it is quite efficient. C is widely used in operating systems (e.g., Linux kernel), embedded systems, and as a foundation for languages like C++ and Java. C does not have any objects. That means we only have functions to use to structure our programs.","title":"What is C"},{"location":"wk_one/#c-development","text":"There are typically six phases of a program in C: editing/programming preprocess These are commands that will change the code that you write examples are #include and #define back in the day, there were no mice to copy and paste things and the terminals were dumb (brains were in the mainframe) so it was difficult to copy and paste things. preprocessor allows you to do things similar to a copy and paste. for #include , think of it like copying and pasting the contents of the included file into this one. for #define , think of it like a text replacement in our code. compile catches syntax errors creates machine code from your code into .o files link combines the .o files and the C Library Object Code into an executable load The operating system loads the executable into memory, preparing it for execution. execute The CPU runs the program, starting from the main function.","title":"C Development"},{"location":"wk_one/#main-function","text":"In C programs begin execution in the main() function. The basic syntax is: int main(void) { // ... do stuff } In modern C (C99 and later), main() implicitly returns 0 if no return statement is given. This only applies to main() \u2014 all other functions require an explicit return if they are non-void. 0 indicates success 1 or any positive int up to 255 signifies an error. We can see the returned value in the terminal by typing: echo $? We can also take command line arguments in main with the following syntax: int main(int argc, char *argv[]) // OR int main(int argc char **argv) Example with CLI arguments In this example, we take in a command line argument along with the function call. The program ends by listing the argument index and the argument value to highlight that the first argument is always the name of the program: #include <stdio.h> // we need to include stdio to get access to puts() and printf() funtions. #include <stdlib.h> // for EXIT_FAILURE and EXIT_SUCCESS macros int main(int argc, char *argv[]) { if (argc != 2) { puts(\"Usage: ./hello_2 <input_name>\"); return EXIT_FAILURE; // EXIT_FAILURE evaluates to 1 and is more portable than hardcoding the value } printf(\"Hello, %s\\n\", argv[1]); puts(\"Welcome to COMP2701\\n\"); puts(\"Here are the arguments that were supplied:\"); for (int i = 0; i < argc; i++) { printf(\"%3d %10s\\n\", i, argv[i]); } puts(\"\"); return EXIT_SUCCESS;// EXIT_SUCCESS evaluates to 0 }","title":"main Function"},{"location":"wk_one/#printing-output","text":"In C, functions like printf() and puts() are used to print output to the screen. Unlike Python or Java, these functions aren\u2019t available by default \u2014 you must include the appropriate header file first. For both printf() and puts() , that file is <stdio.h> (standard I/O). To use them, simply add #include <stdio.h> at the top of your program.","title":"Printing Output"},{"location":"wk_one/#puts","text":"puts() prints out strictly a string of text. We can only pass string literals into puts() . puts() automatically appends a newline character to the end of the string.","title":"puts()"},{"location":"wk_one/#printf","text":"printf() (or print f ormatted) prints out a formatted string where, like python and Java, we can pass in variables. Unlike puts() , printf() does not append a newline character. We must end the string with \\n if we want a new line. In order to use variables in a printf() statement, we must pass in a string with placeholder format specifiers followed by a list of the variables to place in the specifiers. int i = 10; printf(\"The value of i is %d.\\n\", i); // The value of i is 10.","title":"printf()"},{"location":"wk_one/#printf-format-specifiers","text":"The following is a list of some common format specifiers: Specifier Description Example Output Data Type %d Signed decimal integer 42 int %i Signed decimal integer (same as %d ) 42 int %u Unsigned decimal integer 42 unsigned int %zu Unsigned size of objects in bytes 42 size_t %f Decimal floating point 3.141593 float , double %F Decimal floating point (uppercase INF/NAN ) 3.141593 float , double %c Single character A char %s String of characters Hello char * %p Pointer address 0x7ffeefbff5c0 void * %% Literal % character % \u2014","title":"printf() Format Specifiers"},{"location":"wk_one/#getting-user-input","text":"In C there are a few ways to get user input. For our purposes, we will be using scanf() in this course. As with the printing functions, scanf() is found in the <stdio.h> library so make sure to include that in programs that will use scanf() . int number = 0; printf(\"Please enter a number: \"); if (scanf(\"%d\", &number) != 1) { printf(\"Invalid input!\\n\"); return 1; } printf(\"You entered %d.\\n\", number); // Please enter a number: 10 // You entered 10. Unlike printf() and puts() , scanf() requires the address of variables (e.g., &number in the above example). This is because C passes variables by value, meaning a copy is passed unless the address is provided. Since scanf() is looking for a place to store the result, simply passing in the variable as usual would be pointless - we would be writing to a copy and not changing the result. Instead we give scanf() the address in memory where we would like to store the result. In practice, we generally want to prefix any variable that we are storing a result to with the address symbol & . The only time we don't need to do this is with arrays (which we will cover later in this course). Example of scanf() with an array: char name[20]; printf(\"Enter your name: \"); scanf(\"%19s\", name); // note: NO \"&\" here because a string is an array of chars. printf(\"Hello, %s!\\n\", name);","title":"Getting User Input"},{"location":"wk_one/#scanf-format-specifiers","text":"The next notable difference is that there are some slighlty different format specifiers in scanf() . Here is a summary of some of the main differences: Type printf scanf Why it matters double %f %lf Must use %lf in scanf float %f %f scanf(\"%f\") stores to float* only short %d %hd scanf needs h to downcast long %d or %ld %ld Same specifier, but required in scanf - printf can accept a long in %d but could overflow so not advised. long long %lld %lld Required for long long in both","title":"scanf() Format Specifiers"},{"location":"wk_one/#other-gotchas","text":"In addition to needing addresses and the slightly different format specifiers, there are a few other behaviours worth noting.","title":"Other Gotchas"},{"location":"wk_one/#character-input","text":"scanf(\"%c\", &ch) reads any character, including whitespace, which can cause issues due to leftover newlines in the input buffer. int x; char ch; scanf(\"%d\", &x); // user enters: 5\u23ce scanf(\"%c\", &ch); // reads \u23ce as the char!","title":"Character Input"},{"location":"wk_one/#string-inputs","text":"scanf(\"%s\", str) reads input up to the first whitespace (space, tab, or newline). Because of this, using it without a width specifier is unsafe and risks a buffer overflow. In contrast, printf(\"%s\", str) will print the entire string until it sees the \\0 NUL character. char str[5]; scanf(\"%s\", str); // \u274c may overflow if input > 4 chars scanf(\"%4s\", str); // \u2705 safer (leaves 1 byte for '\\0')","title":"String Inputs"},{"location":"wk_one/#note-what-is-a-string-in-c","text":"In C, a string is not a separate type \u2014 it's just an array of char values that ends with a NUL terminator ( '\\0' ). So when you write: char name[] = \"Alice\"; It\u2019s really just shorthand for: char name[] = { 'A', 'l', 'i', 'c', 'e', '\\0' }; That special '\\0' character tells functions like printf(\"%s\", name) where the string ends. Put another way, strings in C are really just arrays of characters with a rule: they must end in '\\0' . Unlike in Python, Java, or C++, there's no built-in \"string\" type \u2014 just arrays and pointers.","title":"Note: What is a String in C?"},{"location":"wk_one/#note-nul-vs-null","text":"These look similar but serve very different purposes in C: Term Type Meaning NUL char ASCII character 0 (value 0x00 ) NULL pointer Null pointer constant (typically 0 or (void*)0 )","title":"Note: NUL vs NULL"},{"location":"wk_one/#nul-0","text":"A character with value 0 Used to terminate C strings Equivalent to: char c = '\\0'; // or: char c = 0;","title":"NUL ('\\0')"},{"location":"wk_one/#null","text":"A macro that represents a null pointer constant Typically defined as ((void *)0) in <stddef.h> Used when a pointer doesn\u2019t point to a valid memory location. Example: int *ptr = NULL; if (ptr == NULL) { // pointer is uninitialized or empty }","title":"NULL"},{"location":"wk_one/#note-what-is-a-char-in-c","text":"In C, a char is a fundamental data type that represents a single character, but at its core, it is simply an 8-bit integer (typically 1 byte) that can hold values from -128 to 127 (for signed char) or 0 to 255 (for unsigned char). These numeric values are often used to represent characters according to the ASCII table, where each number corresponds to a specific character. For example: The character 'A' has an ASCII value of 65. The character 'a' has an ASCII value of 97. The character '0' (the digit zero) has an ASCII value of 48. You can work with char values as either characters or numbers. For instance: char c = 'A'; // Stores the character 'A' (ASCII value 65) printf(\"%c\\n\", c); // Prints: A printf(\"%d\\n\", c); // Prints: 65 This dual nature of char allows you to perform arithmetic operations on characters. For example: char c = 'A'; c = c + 1; // Moves to the next ASCII value ('B' = 66) printf(\"%c\\n\", c); // Prints: B The ASCII table is critical for understanding how characters are represented in C. Common ASCII values include:","title":"Note: What is a char in C?"},{"location":"wk_one/#common-ascii-values","text":"Character ASCII Value Description 'A' 65 Uppercase A 'Z' 90 Uppercase Z 'a' 97 Lowercase a 'z' 122 Lowercase z '0' 48 Digit 0 '9' 57 Digit 9 ' ' 32 Space '\\n' 10 Newline '\\0' 0 NUL (string terminator) Lowercase and Uppercase letters are exactly 32 values away from the same letter When using char in strings or with input/output functions like printf() and scanf() , the ASCII encoding ensures that numeric values are interpreted as readable characters.","title":"Common ASCII Values"},{"location":"wk_seven/","text":"Week 7 Dynamic Memory Allocation Up until now we have been statically creating memory, meaning that the memory size is fixed at compile time (e.g. arrays with a fixed length). In practice, this can cause some issues. For instance, if you declare int arr[100] for user input but only need 10 elements, you waste memory. If the user needs 200 elements, your program crashes. Dynamic memory allocation lets you request memory at runtime, which allows data structures that can grow/shrink (linked lists, dynamic arrays, trees). In Java , using the new keyword, created a dynamic object in memory with automatic garbage collection . This means that when an object is no longer needed, its memory is automatically cleaned up, like throwing away garbage, so the space can be reused. In C , there is no automatic garbage collection. We must manage memory manually, cleaning up our own \u201cgarbage\u201d by freeing memory when we\u2019re done with it, or else we risk memory leaks. Allocating Memory In C we have 3 functions for allocating memory: malloc() , calloc() , and realloc() . The malloc(size) function Allocates a block of uninitialized memory of the specified size in bytes. If it is successful we will be returned a pointer of type void* (which can be assigned to any pointer type). Therefore we should assign it to a pointer variable: int *dynamicArray = NULL; //create an int pointer dynamicArray = malloc(sizeof(int) * 4); // use malloc to allocate and assign the array if (dynamicArray == NULL) // check that malloc did not fail { return EXIT_FAILURE; } If it is not successful it will return NULL . Always check if the return from malloc() is NULL to avoid errors. The calloc() and realloc() Functions calloc(n, size) allocates space for an array of n elements of the specified size and initializes all bits to zero. This can be helpful for arrays where we want to be sure values are initialized. However this comes at the cost of some overhead. realloc(ptr, new_size) changes the size of a previously allocated block. Deallocating Memory with free() When we no longer need a block of dynamically allocated memory, we can use the free(myPtr) function to deallocate the memory and return it to the system. If we don't use free() we could run out of memory causing a memory leak which will likely crash our program. After we free a pointer, we should set the pointer to NULL so that if we accidently refer to that pointer later, we don't refer to invalid memory. free(ptr); ptr = NULL; This also helps us to avoid freeing memory twice. If we free twice we might end up freeing memory that is being used by something else by mistake. free() should only be used with memory we allocated with malloc() , calloc() , or realloc() . Using it on static or stack variables is undefined behaviour. Allocating the Right Amount of Space with sizeof We use sizeof to make sure we allocate the correct amount of memory. int var1; size_t len = sizeof var1; // will give us 4 bytes of memory (the size of an int) Note: If you use sizeof with a pointer you will get the size of a pointer in your system (e.g. 8 bytes on a 64-bit machine) and not the size of the underlying value it points to. So when allocating space for an array dynamically, always use sizeof on the type, not the pointer: int *arr = malloc(sizeof(int) * len); Pointers and the Heap A pointer is a variable that stores the memory address of another variable or block of memory. When you declare a pointer, you use the * operator to indicate that the variable is a pointer type: int *iPtr = NULL; // should always initialize a pointer even if its just to NULL The pointer itself lives on the stack, but it can point to a value in the heap (or anywhere in memory). Once we call malloc() such as iPtr = malloc(sizeof(int)); we are creating a reference to a place in the heap that will be used for this value. When we are dealing with a single scalar (a simple data value - not an array or struct), in order to access the variable on the heap we need to dereference the pointer. The dereference operator is * . The * symbol has two jobs in C: When you declare a pointer, * marks the variable as a pointer type. When you use it with a pointer variable, * means \"follow this pointer to get the value.\" Dynamic Arrays and Pointers When you allocate an array with malloc or calloc, the pointer points to the first element: int *arr = malloc(sizeof(int) * len); You can use this pointer like an array: arr[0] = 1; arr[1] = 2; Remember: sizeof(arr) only gives the size of the pointer, not the total size of the array in memory. Dynamic Memory for Strings One common use of dynamic memory is handling strings of unknown length. For example, imagine we\u2019re reading an input that we know will never exceed 80 characters. We\u2019d declare a char array of length 81 (80 characters plus the terminating NUL ). But if the user only types \"hello\" (6 bytes including '\\0' ), you\u2019ve still reserved 81 bytes,75 of which go unused. We can use dynamic memory allocation to avoid most of that waste. The typical approach has two steps: create a fixed buffer on the stack, then copy it into a malloc \u2019d block on the heap. Read into the stack buffer char buffer[81]; scanf(\"%80[^\\n]\", buffer); // read up to 80 chars or until newline getchar(); // consume the leftover '\\n' Copy into a heap block sized exactly to the string size_t len = strlen(buffer); char *userString = malloc(len + 1); strcpy(userString, buffer); // \u2026do a bunch of stuff and use userString\u2026 free(userString); In this example you still \u201cwaste\u201d 81 bytes on the stack, but only once. Every time you read another line, you reuse that same buffer, and each malloc 'd string on the heap is exactly the length you need (plus one). Note: scanset In the example above, %80[^\\n] uses a scanset to control how scanf reads input. A scanset , written inside square brackets [ ] , tells scanf to match a custom set of characters. The ^ means \"not\" , so [^\\n] means \u201cmatch any characters that are not a newline.\u201d You can think of a scanset as a custom format specifier. It works like a very simple character class, similar to part of a regular expression, but limited to defining which characters to include or exclude. Leetcode 66 Remember that when we pass an array to a function, inside the function it behaves as a pointer to the first element. In this question, int* plusOne(int* digits, ...) \u2014 digits is an array argument that decays to a pointer. The digits array represents a single number, with each element holding one digit of that number. We are adding 1 to this number. The challenge is that adding 1 might cause a carry that affects multiple digits. In some cases, like [9, 9, 9] , the result needs to be one digit longer (e.g., 999 + 1 = 1000 or [1,0,0,0] ). Bob gave us this starter code, which works for simple cases that do not require carrying past the first digit. Our goal is to handle the cases where the result needs an extra digit: int* plusOne(int* digits, int digitsSize, int* returnSize) { // allocate space for the result array int *resultPtr = malloc(sizeof(int) * digitsSize); // populate our result array with the values of digits for (size_t i = 0; i < digitsSize; ++i) { resultPtr[i] = digits[i]; } // add one to the *final* element in the array ++resultPtr[digitsSize - 1]; // set the value of returnSize to digitsSize by *dereferencing* returnSize. *returnSize = digitsSize; // If the increment causes a carry past the first digit, // we will need to make *returnSize = digitsSize + 1 return resultPtr; }","title":"Week 7 - Dynamic Memory Allocation"},{"location":"wk_seven/#week-7","text":"","title":"Week 7"},{"location":"wk_seven/#dynamic-memory-allocation","text":"Up until now we have been statically creating memory, meaning that the memory size is fixed at compile time (e.g. arrays with a fixed length). In practice, this can cause some issues. For instance, if you declare int arr[100] for user input but only need 10 elements, you waste memory. If the user needs 200 elements, your program crashes. Dynamic memory allocation lets you request memory at runtime, which allows data structures that can grow/shrink (linked lists, dynamic arrays, trees). In Java , using the new keyword, created a dynamic object in memory with automatic garbage collection . This means that when an object is no longer needed, its memory is automatically cleaned up, like throwing away garbage, so the space can be reused. In C , there is no automatic garbage collection. We must manage memory manually, cleaning up our own \u201cgarbage\u201d by freeing memory when we\u2019re done with it, or else we risk memory leaks.","title":"Dynamic Memory Allocation"},{"location":"wk_seven/#allocating-memory","text":"In C we have 3 functions for allocating memory: malloc() , calloc() , and realloc() .","title":"Allocating Memory"},{"location":"wk_seven/#the-mallocsize-function","text":"Allocates a block of uninitialized memory of the specified size in bytes. If it is successful we will be returned a pointer of type void* (which can be assigned to any pointer type). Therefore we should assign it to a pointer variable: int *dynamicArray = NULL; //create an int pointer dynamicArray = malloc(sizeof(int) * 4); // use malloc to allocate and assign the array if (dynamicArray == NULL) // check that malloc did not fail { return EXIT_FAILURE; } If it is not successful it will return NULL . Always check if the return from malloc() is NULL to avoid errors.","title":"The malloc(size) function"},{"location":"wk_seven/#the-calloc-and-realloc-functions","text":"calloc(n, size) allocates space for an array of n elements of the specified size and initializes all bits to zero. This can be helpful for arrays where we want to be sure values are initialized. However this comes at the cost of some overhead. realloc(ptr, new_size) changes the size of a previously allocated block.","title":"The calloc() and realloc() Functions"},{"location":"wk_seven/#deallocating-memory-with-free","text":"When we no longer need a block of dynamically allocated memory, we can use the free(myPtr) function to deallocate the memory and return it to the system. If we don't use free() we could run out of memory causing a memory leak which will likely crash our program. After we free a pointer, we should set the pointer to NULL so that if we accidently refer to that pointer later, we don't refer to invalid memory. free(ptr); ptr = NULL; This also helps us to avoid freeing memory twice. If we free twice we might end up freeing memory that is being used by something else by mistake. free() should only be used with memory we allocated with malloc() , calloc() , or realloc() . Using it on static or stack variables is undefined behaviour.","title":"Deallocating Memory with free()"},{"location":"wk_seven/#allocating-the-right-amount-of-space-with-sizeof","text":"We use sizeof to make sure we allocate the correct amount of memory. int var1; size_t len = sizeof var1; // will give us 4 bytes of memory (the size of an int) Note: If you use sizeof with a pointer you will get the size of a pointer in your system (e.g. 8 bytes on a 64-bit machine) and not the size of the underlying value it points to. So when allocating space for an array dynamically, always use sizeof on the type, not the pointer: int *arr = malloc(sizeof(int) * len);","title":"Allocating the Right Amount of Space with sizeof"},{"location":"wk_seven/#pointers-and-the-heap","text":"A pointer is a variable that stores the memory address of another variable or block of memory. When you declare a pointer, you use the * operator to indicate that the variable is a pointer type: int *iPtr = NULL; // should always initialize a pointer even if its just to NULL The pointer itself lives on the stack, but it can point to a value in the heap (or anywhere in memory). Once we call malloc() such as iPtr = malloc(sizeof(int)); we are creating a reference to a place in the heap that will be used for this value. When we are dealing with a single scalar (a simple data value - not an array or struct), in order to access the variable on the heap we need to dereference the pointer. The dereference operator is * . The * symbol has two jobs in C: When you declare a pointer, * marks the variable as a pointer type. When you use it with a pointer variable, * means \"follow this pointer to get the value.\"","title":"Pointers and the Heap"},{"location":"wk_seven/#dynamic-arrays-and-pointers","text":"When you allocate an array with malloc or calloc, the pointer points to the first element: int *arr = malloc(sizeof(int) * len); You can use this pointer like an array: arr[0] = 1; arr[1] = 2; Remember: sizeof(arr) only gives the size of the pointer, not the total size of the array in memory.","title":"Dynamic Arrays and Pointers"},{"location":"wk_seven/#dynamic-memory-for-strings","text":"One common use of dynamic memory is handling strings of unknown length. For example, imagine we\u2019re reading an input that we know will never exceed 80 characters. We\u2019d declare a char array of length 81 (80 characters plus the terminating NUL ). But if the user only types \"hello\" (6 bytes including '\\0' ), you\u2019ve still reserved 81 bytes,75 of which go unused. We can use dynamic memory allocation to avoid most of that waste. The typical approach has two steps: create a fixed buffer on the stack, then copy it into a malloc \u2019d block on the heap. Read into the stack buffer char buffer[81]; scanf(\"%80[^\\n]\", buffer); // read up to 80 chars or until newline getchar(); // consume the leftover '\\n' Copy into a heap block sized exactly to the string size_t len = strlen(buffer); char *userString = malloc(len + 1); strcpy(userString, buffer); // \u2026do a bunch of stuff and use userString\u2026 free(userString); In this example you still \u201cwaste\u201d 81 bytes on the stack, but only once. Every time you read another line, you reuse that same buffer, and each malloc 'd string on the heap is exactly the length you need (plus one).","title":"Dynamic Memory for Strings"},{"location":"wk_seven/#note-scanset","text":"In the example above, %80[^\\n] uses a scanset to control how scanf reads input. A scanset , written inside square brackets [ ] , tells scanf to match a custom set of characters. The ^ means \"not\" , so [^\\n] means \u201cmatch any characters that are not a newline.\u201d You can think of a scanset as a custom format specifier. It works like a very simple character class, similar to part of a regular expression, but limited to defining which characters to include or exclude.","title":"Note: scanset"},{"location":"wk_seven/#leetcode-66","text":"Remember that when we pass an array to a function, inside the function it behaves as a pointer to the first element. In this question, int* plusOne(int* digits, ...) \u2014 digits is an array argument that decays to a pointer. The digits array represents a single number, with each element holding one digit of that number. We are adding 1 to this number. The challenge is that adding 1 might cause a carry that affects multiple digits. In some cases, like [9, 9, 9] , the result needs to be one digit longer (e.g., 999 + 1 = 1000 or [1,0,0,0] ). Bob gave us this starter code, which works for simple cases that do not require carrying past the first digit. Our goal is to handle the cases where the result needs an extra digit: int* plusOne(int* digits, int digitsSize, int* returnSize) { // allocate space for the result array int *resultPtr = malloc(sizeof(int) * digitsSize); // populate our result array with the values of digits for (size_t i = 0; i < digitsSize; ++i) { resultPtr[i] = digits[i]; } // add one to the *final* element in the array ++resultPtr[digitsSize - 1]; // set the value of returnSize to digitsSize by *dereferencing* returnSize. *returnSize = digitsSize; // If the increment causes a carry past the first digit, // we will need to make *returnSize = digitsSize + 1 return resultPtr; }","title":"Leetcode 66"},{"location":"wk_six/","text":"Week 6 Passing an Array to a Function To pass an array as an argument to a function simply use its name without square brackets. myFunc(myArr); When we pass an array to a function in C, we are really passing a pointer to the first element of the array. This means the function can modify the original array \u2014 we are not creating a copy. That is, we are passing by reference . When we pass an array in to a function which doesn't need to modify it, for example searching an array for max, we can pass it as const . This is like putting up guard rails to make sure that we don't actually change the array. Multi-Dimensional Arrays Multidimensional arrays are arrays within arrays. The simplest kind is a 2-dimensional array. In a 2-dimensional array, the first index is the row and the second is the column. Think of it like a spreadsheet: However, memory is only one-dimensional. Therefore, a 2D array is stored like this: The number of columns determines where each new row starts in memory. This is because C stores arrays in row-major order \u2014 row by row. We can compute the address of any element in a 2D array with this formula: start_loc + (rowNum * numberOfColumns) + colNum where start_loc is the address of the first element of the array. Multi-Dimensional Arrays with Initializer Lists When we initialize a 2d array, we can use additional sets of {} to signify rows int arr[3][3] = { {0, 1, 2}, {3, 4, 5}, {6, 7, 8} }; But this is just for readability \u2014 the underlying memory layout is the same as: int arr[3][3] = {0,1,2,3,4,5,6,7,8}; Both arrays will be identical, but the first is more readable. Passing a Multi-Dimensional Array to a Function When passing a multi-dimensional array to a function, we must explicitly specify the size of all dimensions except the first. This is because the compiler needs to know the number of columns to correctly calculate where each row starts in memory. void printArray(int arr[][3], size_t nRows); We do not need to specify the first dimension (number of rows). Looping Over Multi Dim Arrays Bob specifically said do not use variables like i or j when looping over arrays. Instead use things like r , c or row , col or something else that is similarly explicit. for (size_t row = 0; row < 3; ++row) { for (size_t col = 0; col < 4; ++col) { printf(\"%d \", arr[row][col]); } printf(\"\\n\"); } Variable-Length Arrays (VLAs) A variable-length array is an array whose size is not known at compile time. It can be created using a runtime value. int size; scanf(\"%d\", &size); int arr[size]; However, not all compilers support VLAs. Note: Bob very specifically said don't use VLAs in this course. If needed, dynamic arrays should be created using malloc, calloc, or realloc.","title":"Week 6 - Multi-Dimensional Arrays"},{"location":"wk_six/#week-6","text":"","title":"Week 6"},{"location":"wk_six/#passing-an-array-to-a-function","text":"To pass an array as an argument to a function simply use its name without square brackets. myFunc(myArr); When we pass an array to a function in C, we are really passing a pointer to the first element of the array. This means the function can modify the original array \u2014 we are not creating a copy. That is, we are passing by reference . When we pass an array in to a function which doesn't need to modify it, for example searching an array for max, we can pass it as const . This is like putting up guard rails to make sure that we don't actually change the array.","title":"Passing an Array to a Function"},{"location":"wk_six/#multi-dimensional-arrays","text":"Multidimensional arrays are arrays within arrays. The simplest kind is a 2-dimensional array. In a 2-dimensional array, the first index is the row and the second is the column. Think of it like a spreadsheet: However, memory is only one-dimensional. Therefore, a 2D array is stored like this: The number of columns determines where each new row starts in memory. This is because C stores arrays in row-major order \u2014 row by row. We can compute the address of any element in a 2D array with this formula: start_loc + (rowNum * numberOfColumns) + colNum where start_loc is the address of the first element of the array.","title":"Multi-Dimensional Arrays"},{"location":"wk_six/#multi-dimensional-arrays-with-initializer-lists","text":"When we initialize a 2d array, we can use additional sets of {} to signify rows int arr[3][3] = { {0, 1, 2}, {3, 4, 5}, {6, 7, 8} }; But this is just for readability \u2014 the underlying memory layout is the same as: int arr[3][3] = {0,1,2,3,4,5,6,7,8}; Both arrays will be identical, but the first is more readable.","title":"Multi-Dimensional Arrays with Initializer Lists"},{"location":"wk_six/#passing-a-multi-dimensional-array-to-a-function","text":"When passing a multi-dimensional array to a function, we must explicitly specify the size of all dimensions except the first. This is because the compiler needs to know the number of columns to correctly calculate where each row starts in memory. void printArray(int arr[][3], size_t nRows); We do not need to specify the first dimension (number of rows).","title":"Passing a Multi-Dimensional Array to a Function"},{"location":"wk_six/#looping-over-multi-dim-arrays","text":"Bob specifically said do not use variables like i or j when looping over arrays. Instead use things like r , c or row , col or something else that is similarly explicit. for (size_t row = 0; row < 3; ++row) { for (size_t col = 0; col < 4; ++col) { printf(\"%d \", arr[row][col]); } printf(\"\\n\"); }","title":"Looping Over Multi Dim Arrays"},{"location":"wk_six/#variable-length-arrays-vlas","text":"A variable-length array is an array whose size is not known at compile time. It can be created using a runtime value. int size; scanf(\"%d\", &size); int arr[size]; However, not all compilers support VLAs. Note: Bob very specifically said don't use VLAs in this course. If needed, dynamic arrays should be created using malloc, calloc, or realloc.","title":"Variable-Length Arrays (VLAs)"},{"location":"wk_ten/","text":"Week 10 This week just covers a bunch of character and string functions. Character-handling Library ( <ctype.h> ) Each function in the <ctype.h> library accepts an unsigned char (which can be represented as an int ) or EOF ( EOF is usually -1) as input. Character Type Checking Functions (digits, letters, hex) isdigit(int c) Returns true if c is a digit (0\u20139), otherwise returns false. isalpha(int c) Returns true if c is a letter (a\u2013z or A\u2013Z), otherwise returns false. isalnum(int c) Returns true if c is either a digit or a letter, otherwise returns false. isxdigit(int c) Returns true if c is a valid hexadecimal digit (0\u20139, a\u2013f, A\u2013F). Case Checking and Conversion islower(int c) Returns true if c is a lowercase letter. isupper(int c) Returns true if c is an uppercase letter. tolower(int c) If c is an uppercase letter, returns its lowercase equivalent. Otherwise, returns c unchanged. toupper(int c) If c is a lowercase letter, returns its uppercase equivalent. Otherwise, returns c unchanged. Whitespace and Control Checking isblank(int c) Returns true if c is a space or tab. isspace(int c) Returns true if c is any whitespace character (space, tab, newline, vertical tab, form feed, carriage return). iscntrl(int c) Returns true if c is a control character (e.g., newline, tab, backspace). ispunct(int c) Returns true if c is a printable character but not a space or alphanumeric character. Printing Character Checking A printing character is any character that results in a visible symbol on screen or paper. This includes letters, digits, punctuation, and symbols. isprint(int c) Returns true if c is any printable character, including space. isgraph(int c) Returns true if c is any printable character except space. String Conversion Functions ( <stdlib.h> ) The standard library provides functions that convert the initial part of a string to an integer or floating-point number. Parsing stops as soon as a character is encountered that is not valid for the specified number format. If the input string does not start with a valid numeric sequence, the function returns 0 and *endPtr is set to point to the original nPtr (input). If the base (for functions that have a base) is set to 0 then the function will auto-detect the base. If the number starts with 0 it will be interpreted as octal . If the number starts with 0x or 0X it will be interpreted as hex . If there is no prefix it will be interpreted as decimal . The base can be any number up to 36 (10 digits + 26 characters). Each function takes a second argument endPtr , which is used to return a pointer to the rest of the string (i.e., the character immediately after the parsed number). If you don't need this information, you can pass NULL instead. strtod(const char *nPtr, char **endPtr) Converts nPtr to a double . Stops at the first invalid character and sets endPtr to point to it. strtol(const char *nPtr, char **endPtr, int base) Converts nPtr to a long . Accepts a numerical base (e.g., 10 for decimal, 16 for hex). strtoul(const char *nPtr, char **endPtr, int base) Converts nPtr to an unsigned long . Otherwise behaves like strtol .","title":"Week 10 - String Functions"},{"location":"wk_ten/#week-10","text":"This week just covers a bunch of character and string functions.","title":"Week 10"},{"location":"wk_ten/#character-handling-library-ctypeh","text":"Each function in the <ctype.h> library accepts an unsigned char (which can be represented as an int ) or EOF ( EOF is usually -1) as input.","title":"Character-handling Library (&lt;ctype.h&gt;)"},{"location":"wk_ten/#character-type-checking-functions-digits-letters-hex","text":"","title":"Character Type Checking Functions (digits, letters, hex)"},{"location":"wk_ten/#isdigitint-c","text":"Returns true if c is a digit (0\u20139), otherwise returns false.","title":"isdigit(int c)"},{"location":"wk_ten/#isalphaint-c","text":"Returns true if c is a letter (a\u2013z or A\u2013Z), otherwise returns false.","title":"isalpha(int c)"},{"location":"wk_ten/#isalnumint-c","text":"Returns true if c is either a digit or a letter, otherwise returns false.","title":"isalnum(int c)"},{"location":"wk_ten/#isxdigitint-c","text":"Returns true if c is a valid hexadecimal digit (0\u20139, a\u2013f, A\u2013F).","title":"isxdigit(int c)"},{"location":"wk_ten/#case-checking-and-conversion","text":"","title":"Case Checking and Conversion"},{"location":"wk_ten/#islowerint-c","text":"Returns true if c is a lowercase letter.","title":"islower(int c)"},{"location":"wk_ten/#isupperint-c","text":"Returns true if c is an uppercase letter.","title":"isupper(int c)"},{"location":"wk_ten/#tolowerint-c","text":"If c is an uppercase letter, returns its lowercase equivalent. Otherwise, returns c unchanged.","title":"tolower(int c)"},{"location":"wk_ten/#toupperint-c","text":"If c is a lowercase letter, returns its uppercase equivalent. Otherwise, returns c unchanged.","title":"toupper(int c)"},{"location":"wk_ten/#whitespace-and-control-checking","text":"","title":"Whitespace and Control Checking"},{"location":"wk_ten/#isblankint-c","text":"Returns true if c is a space or tab.","title":"isblank(int c)"},{"location":"wk_ten/#isspaceint-c","text":"Returns true if c is any whitespace character (space, tab, newline, vertical tab, form feed, carriage return).","title":"isspace(int c)"},{"location":"wk_ten/#iscntrlint-c","text":"Returns true if c is a control character (e.g., newline, tab, backspace).","title":"iscntrl(int c)"},{"location":"wk_ten/#ispunctint-c","text":"Returns true if c is a printable character but not a space or alphanumeric character.","title":"ispunct(int c)"},{"location":"wk_ten/#printing-character-checking","text":"A printing character is any character that results in a visible symbol on screen or paper. This includes letters, digits, punctuation, and symbols.","title":"Printing Character Checking"},{"location":"wk_ten/#isprintint-c","text":"Returns true if c is any printable character, including space.","title":"isprint(int c)"},{"location":"wk_ten/#isgraphint-c","text":"Returns true if c is any printable character except space.","title":"isgraph(int c)"},{"location":"wk_ten/#string-conversion-functions-stdlibh","text":"The standard library provides functions that convert the initial part of a string to an integer or floating-point number. Parsing stops as soon as a character is encountered that is not valid for the specified number format. If the input string does not start with a valid numeric sequence, the function returns 0 and *endPtr is set to point to the original nPtr (input). If the base (for functions that have a base) is set to 0 then the function will auto-detect the base. If the number starts with 0 it will be interpreted as octal . If the number starts with 0x or 0X it will be interpreted as hex . If there is no prefix it will be interpreted as decimal . The base can be any number up to 36 (10 digits + 26 characters). Each function takes a second argument endPtr , which is used to return a pointer to the rest of the string (i.e., the character immediately after the parsed number). If you don't need this information, you can pass NULL instead.","title":"String Conversion Functions (&lt;stdlib.h&gt;)"},{"location":"wk_ten/#strtodconst-char-nptr-char-endptr","text":"Converts nPtr to a double . Stops at the first invalid character and sets endPtr to point to it.","title":"strtod(const char *nPtr, char **endPtr)"},{"location":"wk_ten/#strtolconst-char-nptr-char-endptr-int-base","text":"Converts nPtr to a long . Accepts a numerical base (e.g., 10 for decimal, 16 for hex).","title":"strtol(const char *nPtr, char **endPtr, int base)"},{"location":"wk_ten/#strtoulconst-char-nptr-char-endptr-int-base","text":"Converts nPtr to an unsigned long . Otherwise behaves like strtol .","title":"strtoul(const char *nPtr, char **endPtr, int base)"},{"location":"wk_three/","text":"Week 3 Functions A function is a self-contained block of code designed to accomplish a specific task. Functions enable: Divide and conquer : Developing large programs by combining smaller, reusable parts. Abstraction : Hiding implementation details behind a meaningful name allowing a developer to use a function without worrying about the underlying implementation. Decomposition : Breaking complex problems into manageable components - when a function can't be defined easily, we can decompose it into a series of smaller functions which are better defined. Programs are easier to write, test, debug, and maintain when structured as a collection of functions. Functional Program Structure In C, all programs must have a main() function. It serves as the entry point of execution. However, instead of doing everything itself we can functionalize the program (breaking it into individual functions) allowing main() to focus on the overall logic while calling other functions to do the actual work. This setup reflects a hierarchical calling structure, where main() is the top-level caller ( boss ) and delegates tasks to helper functions ( workers ). Function Definition A function in C has the following definition: return_type function_name(parameter_list) { statements } The return_type tells the type returned from the function ( void if there is no return value). The function_name is the identifier for this function, it should be a clear, easy-to-understand name. The parameter_list is a comma-separated list of input variables and their types The statements are the actions taken by the function. If there is a return_type other than void the function must have a return statement in it. Example: int square(int number) { return number * number; } Function Prototype Recall that C executes code sequentially. If it sees a function caller before the definition of that function, it won't know what to do and the compiler will give an error. We can get around this, somewhat, by placing functions in the order that they are being called but this quickly becomes a mess and often can't even be fully achieved. To get around this, we can include a prototype near the start of the program that tells the compiler what a function looks like before it's used. int square(int number); This prototype allows the compiler to check that the function call has the right signature and also ensures that the return type is compatible for whatever the function is being called to do. Prototypes must end in a semicolon ; and do not have any of the statements listed. You can optionally omit the parameter names and only include types for the parameters int square(int); Note: the idea of prototypes didn't always exist in C . It is actually borrowed from C++ . Before this, the compiler wouldn't check the behaviour of functions meaning that no errors would be thrown at compilation but this led to more issues at runtime due to improper use of functions. Argument Coercion Function prototypes implicitly convert arguments to the appropriate type a process known as argument coercion . printf(\"%.3f\\n\", sqrt(4)); // this works despite sqrt expecting a double. //prints 2.000 We need to be careful with these coercions as if they are used incorrectly they can cause information to be lost. For example, if you pass a double to a function expecting an int the information after the decimal will be dropped. If that information was valuable this can lead to incorrect results. Furthermore, if a function expects a small type such as an short but we pass it a larger type such as a long we risk changing the value as any extra bits will be dropped from the long . Mixed-Type Expressions When we perform an operation which has multiple types, the compiler will make temporary copies of all the values to the highest type used: a process known as promotion . For example, if we have a double and a float everything is converted to a double because it is the higher size type. Function-Call Stack A stack is a common data-structure. It is often compared with a pile of plates. Fresh plates are placed on the top (known as being pushed onto the stack) and when they are removed we also grab from the top (and pop off the stack). Stacks are last-in, first-out (LIFO) . The function-call stack is what supports the underlying function call and return for a program. When we call a function, we might call other functions. Each function needs to remember who to return its value to. The function-call stack makes this easy. Each time a function calls another function, we push a stack frame containing the return address for the new function to return to the old function. Once a function returns, the associated stack frame is popped and returns control to the return address that is specified in that stack frame. Because it is a stack, each function will always* find its return address at the top of the stack, once it is used it is popped off the stack so the next function sees the correct address. If we push too many functions to the stack, we will eventually run out of memory and will have a stack overflow error crashing the program. Pass Arguments by Value and by Reference In programming, there are two ways to pass an argument into a function: pass by value and pass by reference . Passing by value means that we copy the value of an argument into the function. Since the function then works on a copy, it does not affect the original variable's value. int c = 5; superFunction(c); // will print 5000; printf(\"outside: %d\\n\", c); // will print 5 void superFunction(int num){ num *= 1000; printf(\"inside: %d\\n\", num); return } Passing by reference means that we pass the actual variable (or at least a reference to it) into the function. This means that the function does modify the original variable's value as a result. In C all arguments are passed by value . With that said, we can use pointers to achieve pass by reference functionality. Random-Number Generation In C the standard library <stdlib.h> has a few useful functions that we can use to generate random numbers. In this course we will look at rand() and srand() . To create a random value we can simply use rand() as follows: int value = rand(); . This will generate a random value between 0 and RAND_MAX (which is a symbolic constant defined in <stdlib.h> and is at least 32,767 but can be higher depending on system/compiler). Note: even though its defined as at least 32,767, the value is always of type int (or more clearly signed int ) and not short . We often want to limit the range of possible values returned when we generate a random number. For example, if we wanted to simulate a dice roll, we would only want 1, 2, 3, 4, 5, 6 as our possible values but as we see rand() return between 0 and RAND_MAX which is way more numbers than we want. To get around this, we can use the modulo operator and work just with remainders. int diceValue = 1 + (rand() % 6) // note: rand() % 6 will return a number between 0 and 5. We add 1 to *shift* the result to 1 through 6. This is known as scaling . In our example above, 6 is our scaling factor and adding one is our shift . Seeds and srand() Each subsequent call to rand() calculates a new random number based on the previous result. This works within a single execution of the program, however if we run the program again we will discover that it returns the exact same results the next time it is run. This is because rand() starts with a default seed or starting value (usually just 1). To get randomized results for every execution, we can use the srand() function to s eed rand() . Note that this function just changes the seed value that will be used by rand() . After seeding, we still use the regular rand() function to generate our random numbers. That is, we only run srand() once to set things up. We can pass any number to srand() but if we hardcode that number in the program we will end up with the same issue, namely that every execution will start with the same seed and thus have the same results. time(NULL) To get around this, we can use time(NULL) as our seed: srand(time(NULL)); . time(NULL) returns the number of seconds that have passed since midnight Jan 1, 1970 and therefore is changing every second. Secure Random Number Generation The standard C rand() function is fine for textbook examples but is not suitable for secure or industrial-strength applications. According to the C standard: \"There are no guarantees as to the quality of the random sequence produced, and some implementations are known to produce sequences with distressingly non-random low-order bits.\" Secure Alternatives for Production For cryptography or any security-critical task, rand() is not safe. Instead, use platform-specific secure random-number generators: Platform Recommended Function Notes Windows BCryptGenRandom Part of the Cryptography API: Next Generation ( docs ) Linux / POSIX random View details with man random in terminal macOS arc4random View details with man arc4random in terminal Refer to the CERT Secure Coding Guideline: MSC30-C: Do not use the rand() function for generating pseudorandom numbers Always use secure generators when random numbers must not be predictable.","title":"Week 3 - Functions, Scope, and Header Files"},{"location":"wk_three/#week-3","text":"","title":"Week 3"},{"location":"wk_three/#functions","text":"A function is a self-contained block of code designed to accomplish a specific task. Functions enable: Divide and conquer : Developing large programs by combining smaller, reusable parts. Abstraction : Hiding implementation details behind a meaningful name allowing a developer to use a function without worrying about the underlying implementation. Decomposition : Breaking complex problems into manageable components - when a function can't be defined easily, we can decompose it into a series of smaller functions which are better defined. Programs are easier to write, test, debug, and maintain when structured as a collection of functions.","title":"Functions"},{"location":"wk_three/#functional-program-structure","text":"In C, all programs must have a main() function. It serves as the entry point of execution. However, instead of doing everything itself we can functionalize the program (breaking it into individual functions) allowing main() to focus on the overall logic while calling other functions to do the actual work. This setup reflects a hierarchical calling structure, where main() is the top-level caller ( boss ) and delegates tasks to helper functions ( workers ).","title":"Functional Program Structure"},{"location":"wk_three/#function-definition","text":"A function in C has the following definition: return_type function_name(parameter_list) { statements } The return_type tells the type returned from the function ( void if there is no return value). The function_name is the identifier for this function, it should be a clear, easy-to-understand name. The parameter_list is a comma-separated list of input variables and their types The statements are the actions taken by the function. If there is a return_type other than void the function must have a return statement in it. Example: int square(int number) { return number * number; }","title":"Function Definition"},{"location":"wk_three/#function-prototype","text":"Recall that C executes code sequentially. If it sees a function caller before the definition of that function, it won't know what to do and the compiler will give an error. We can get around this, somewhat, by placing functions in the order that they are being called but this quickly becomes a mess and often can't even be fully achieved. To get around this, we can include a prototype near the start of the program that tells the compiler what a function looks like before it's used. int square(int number); This prototype allows the compiler to check that the function call has the right signature and also ensures that the return type is compatible for whatever the function is being called to do. Prototypes must end in a semicolon ; and do not have any of the statements listed. You can optionally omit the parameter names and only include types for the parameters int square(int); Note: the idea of prototypes didn't always exist in C . It is actually borrowed from C++ . Before this, the compiler wouldn't check the behaviour of functions meaning that no errors would be thrown at compilation but this led to more issues at runtime due to improper use of functions.","title":"Function Prototype"},{"location":"wk_three/#argument-coercion","text":"Function prototypes implicitly convert arguments to the appropriate type a process known as argument coercion . printf(\"%.3f\\n\", sqrt(4)); // this works despite sqrt expecting a double. //prints 2.000 We need to be careful with these coercions as if they are used incorrectly they can cause information to be lost. For example, if you pass a double to a function expecting an int the information after the decimal will be dropped. If that information was valuable this can lead to incorrect results. Furthermore, if a function expects a small type such as an short but we pass it a larger type such as a long we risk changing the value as any extra bits will be dropped from the long .","title":"Argument Coercion"},{"location":"wk_three/#mixed-type-expressions","text":"When we perform an operation which has multiple types, the compiler will make temporary copies of all the values to the highest type used: a process known as promotion . For example, if we have a double and a float everything is converted to a double because it is the higher size type.","title":"Mixed-Type Expressions"},{"location":"wk_three/#function-call-stack","text":"A stack is a common data-structure. It is often compared with a pile of plates. Fresh plates are placed on the top (known as being pushed onto the stack) and when they are removed we also grab from the top (and pop off the stack). Stacks are last-in, first-out (LIFO) . The function-call stack is what supports the underlying function call and return for a program. When we call a function, we might call other functions. Each function needs to remember who to return its value to. The function-call stack makes this easy. Each time a function calls another function, we push a stack frame containing the return address for the new function to return to the old function. Once a function returns, the associated stack frame is popped and returns control to the return address that is specified in that stack frame. Because it is a stack, each function will always* find its return address at the top of the stack, once it is used it is popped off the stack so the next function sees the correct address. If we push too many functions to the stack, we will eventually run out of memory and will have a stack overflow error crashing the program.","title":"Function-Call Stack"},{"location":"wk_three/#pass-arguments-by-value-and-by-reference","text":"In programming, there are two ways to pass an argument into a function: pass by value and pass by reference . Passing by value means that we copy the value of an argument into the function. Since the function then works on a copy, it does not affect the original variable's value. int c = 5; superFunction(c); // will print 5000; printf(\"outside: %d\\n\", c); // will print 5 void superFunction(int num){ num *= 1000; printf(\"inside: %d\\n\", num); return } Passing by reference means that we pass the actual variable (or at least a reference to it) into the function. This means that the function does modify the original variable's value as a result. In C all arguments are passed by value . With that said, we can use pointers to achieve pass by reference functionality.","title":"Pass Arguments by Value and by Reference"},{"location":"wk_three/#random-number-generation","text":"In C the standard library <stdlib.h> has a few useful functions that we can use to generate random numbers. In this course we will look at rand() and srand() . To create a random value we can simply use rand() as follows: int value = rand(); . This will generate a random value between 0 and RAND_MAX (which is a symbolic constant defined in <stdlib.h> and is at least 32,767 but can be higher depending on system/compiler). Note: even though its defined as at least 32,767, the value is always of type int (or more clearly signed int ) and not short . We often want to limit the range of possible values returned when we generate a random number. For example, if we wanted to simulate a dice roll, we would only want 1, 2, 3, 4, 5, 6 as our possible values but as we see rand() return between 0 and RAND_MAX which is way more numbers than we want. To get around this, we can use the modulo operator and work just with remainders. int diceValue = 1 + (rand() % 6) // note: rand() % 6 will return a number between 0 and 5. We add 1 to *shift* the result to 1 through 6. This is known as scaling . In our example above, 6 is our scaling factor and adding one is our shift .","title":"Random-Number Generation"},{"location":"wk_three/#seeds-and-srand","text":"Each subsequent call to rand() calculates a new random number based on the previous result. This works within a single execution of the program, however if we run the program again we will discover that it returns the exact same results the next time it is run. This is because rand() starts with a default seed or starting value (usually just 1). To get randomized results for every execution, we can use the srand() function to s eed rand() . Note that this function just changes the seed value that will be used by rand() . After seeding, we still use the regular rand() function to generate our random numbers. That is, we only run srand() once to set things up. We can pass any number to srand() but if we hardcode that number in the program we will end up with the same issue, namely that every execution will start with the same seed and thus have the same results.","title":"Seeds and srand()"},{"location":"wk_three/#timenull","text":"To get around this, we can use time(NULL) as our seed: srand(time(NULL)); . time(NULL) returns the number of seconds that have passed since midnight Jan 1, 1970 and therefore is changing every second.","title":"time(NULL)"},{"location":"wk_three/#secure-random-number-generation","text":"The standard C rand() function is fine for textbook examples but is not suitable for secure or industrial-strength applications. According to the C standard: \"There are no guarantees as to the quality of the random sequence produced, and some implementations are known to produce sequences with distressingly non-random low-order bits.\"","title":"Secure Random Number Generation"},{"location":"wk_three/#secure-alternatives-for-production","text":"For cryptography or any security-critical task, rand() is not safe. Instead, use platform-specific secure random-number generators: Platform Recommended Function Notes Windows BCryptGenRandom Part of the Cryptography API: Next Generation ( docs ) Linux / POSIX random View details with man random in terminal macOS arc4random View details with man arc4random in terminal Refer to the CERT Secure Coding Guideline: MSC30-C: Do not use the rand() function for generating pseudorandom numbers Always use secure generators when random numbers must not be predictable.","title":"Secure Alternatives for Production"},{"location":"wk_two/","text":"Week 2 Algorithms Definition: An algorithm is a procedure for solving a problem, defined by: The actions to execute. The order in which these actions execute. The order of statement execution is called program control. Control Structures By default, C programs execute statements in the order they are written (sequential execution). However, control structures allow transferring control to execute statements out of sequence. There are three types: Sequence Structure: Statements execute in the order written. Selection Structures: if, if...else, and switch choose the next statement based on a condition. Iteration Structures: for, while, and do...while repeat statements until a condition is met. Selection Structures if and if...else Statements The if statement evaluates a condition and executes a block if true. An optional else block executes if false. Example: int x = 5; if (x > 0) { printf(\"x is positive\\n\"); } else { printf(\"x is non-positive\\n\"); } // Output: x is positive Ternary Conditional Operator The ternary operator ( ?: ) is a concise alternative to if...else for simple conditions. It returns the value after ? if the condition is true, or the value after : if false. int x = 5; puts(x > 0 ? \"good\" : \"bad\"); // Output: good Note: Use the ternary operator for simple expressions but probably best to avoid for more complex expressions as it can reduce readability for complex logic. Short-Circuit Evaluation In C , logical operators ( && and || ) use short-circuit evaluation. If the result of an expression can be determined early, the remaining parts are not evaluated. For && ( AND ): If the first condition is false , the second is not evaluated. For || ( OR ): If the first condition is true , the second is not evaluated. Example: int x = 0, y = 5; if (x != 0 && y / x > 2) { // y / x not evaluated due to x == 0 printf(\"This won't print\\n\"); } This prevents errors like division by zero. switch() Statement switch provides a clean way to branch based on the value of a single variable (usually int or char ). It\u2019s often used instead of long if...else if chains. int grade = 2; switch (grade) { case 1: puts(\"Excellent\"); break; case 2: puts(\"Good\"); break; case 3: puts(\"Fair\"); break; default: puts(\"Invalid\"); } If we don't put a break; after a case execution will fall through to the next case. Sometimes this is intentional when multiple values will have the same response. Other times, this is a bug and will lead to unexpected behaviour. case 1: // Fall-through intentional case 2: puts(\"Grade is 1 or 2\"); break; Iteration Structures while Loop The while loop repeats as long as a condition is true, checking the condition before each iteration. int i = 3; while (i < 10) { printf(\"%d \", i); i++; } // Output: 3 4 5 6 7 8 9 do...while Loop The do...while loop executes at least once, checking the condition after each iteration. int i = 3; do { printf(\"%d \", i); i++; } while (i < 4); // Output: 3 for Loop The for loop is used for iterations with a known number of repetitions, combining initialization, condition, and increment. for (int i = 0; i < 5; i++) { printf(\"%d \", i); } // Output: 0 1 2 3 4 Pre-Increment vs. Post-Increment Pre-increment ( ++i ): Increments i before using its value. Post-increment ( i++ ): Uses i \u2019s value, then increments it. Example: int i = 0; printf(\"%d\\n\", i++); // Prints 0, then i becomes 1 printf(\"%d\\n\", ++i); // Increments i to 2, then prints 2 Bob's Preference: Use pre-increment ( ++i ) in loops for slight performance benefits (avoids creating a temporary copy) and clarity. In a for loop, the increment step (e.g., i++ or ++i in for (int i = 0; i < 5; i++) ) occurs after the loop body executes, so the choice of pre- or post-increment doesn\u2019t affect the loop\u2019s iteration behavior. Both produce the same sequence of loop iterations. However, within the loop body, the choice matters if the incremented value is used. For example, if you use i++ or ++i to modify another variable, the result differs. Loop Exit Conditions When using different increment types or loop structures, carefully consider when the loop exits: Integer increments: Ensure the condition accounts for the final value. int i = 0; while (i < 5) { printf(\"%d \", i); i += 2; // Increments by 2 } // Output: 0 2 4 Floating-point increments: Be cautious with floating-point conditions due to precision issues (basically, never do this). float i = 0.0; while (i < 1.0) { printf(\"%.1f \", i); i += 0.1; } // May not stop exactly at 1.0 due to floating-point imprecision Loop type choice: Use while for condition-driven loops. Use do...while when at least one iteration is needed. Use for for counted loops with clear start and end points. Casting Numbers When dividing two integers, the result is an integer, truncating any decimal part. To retain decimals, cast one or both operands to float or double . int a = 2, b = 3; float result = (float)a / b; // Cast a to float printf(\"%.2f\\n\", result); // %.2f formats to 2 decimal places // Output: 0.67 Note: Use %.nf in printf to specify n decimal places (e.g., %.2f for two decimals). Arithmetic Overflow The <limits.h> header provides constraints for various types based on the underlying system limits. Example: #include <limits.h> #include <stdio.h> int main(void) { int x = INT_MAX; if (x > INT_MAX - 1) { // Check for overflow printf(\"Cannot increment without overflow\\n\"); } else { x++; } return 0; }","title":"Week 2 - Operators, Math, and Program Flow"},{"location":"wk_two/#week-2","text":"","title":"Week 2"},{"location":"wk_two/#algorithms","text":"Definition: An algorithm is a procedure for solving a problem, defined by: The actions to execute. The order in which these actions execute. The order of statement execution is called program control.","title":"Algorithms"},{"location":"wk_two/#control-structures","text":"By default, C programs execute statements in the order they are written (sequential execution). However, control structures allow transferring control to execute statements out of sequence. There are three types: Sequence Structure: Statements execute in the order written. Selection Structures: if, if...else, and switch choose the next statement based on a condition. Iteration Structures: for, while, and do...while repeat statements until a condition is met.","title":"Control Structures"},{"location":"wk_two/#selection-structures","text":"","title":"Selection Structures"},{"location":"wk_two/#if-and-ifelse-statements","text":"The if statement evaluates a condition and executes a block if true. An optional else block executes if false. Example: int x = 5; if (x > 0) { printf(\"x is positive\\n\"); } else { printf(\"x is non-positive\\n\"); } // Output: x is positive","title":"if and if...else Statements"},{"location":"wk_two/#ternary-conditional-operator","text":"The ternary operator ( ?: ) is a concise alternative to if...else for simple conditions. It returns the value after ? if the condition is true, or the value after : if false. int x = 5; puts(x > 0 ? \"good\" : \"bad\"); // Output: good Note: Use the ternary operator for simple expressions but probably best to avoid for more complex expressions as it can reduce readability for complex logic.","title":"Ternary Conditional Operator"},{"location":"wk_two/#short-circuit-evaluation","text":"In C , logical operators ( && and || ) use short-circuit evaluation. If the result of an expression can be determined early, the remaining parts are not evaluated. For && ( AND ): If the first condition is false , the second is not evaluated. For || ( OR ): If the first condition is true , the second is not evaluated. Example: int x = 0, y = 5; if (x != 0 && y / x > 2) { // y / x not evaluated due to x == 0 printf(\"This won't print\\n\"); } This prevents errors like division by zero.","title":"Short-Circuit Evaluation"},{"location":"wk_two/#switch-statement","text":"switch provides a clean way to branch based on the value of a single variable (usually int or char ). It\u2019s often used instead of long if...else if chains. int grade = 2; switch (grade) { case 1: puts(\"Excellent\"); break; case 2: puts(\"Good\"); break; case 3: puts(\"Fair\"); break; default: puts(\"Invalid\"); } If we don't put a break; after a case execution will fall through to the next case. Sometimes this is intentional when multiple values will have the same response. Other times, this is a bug and will lead to unexpected behaviour. case 1: // Fall-through intentional case 2: puts(\"Grade is 1 or 2\"); break;","title":"switch() Statement"},{"location":"wk_two/#iteration-structures","text":"","title":"Iteration Structures"},{"location":"wk_two/#while-loop","text":"The while loop repeats as long as a condition is true, checking the condition before each iteration. int i = 3; while (i < 10) { printf(\"%d \", i); i++; } // Output: 3 4 5 6 7 8 9","title":"while Loop"},{"location":"wk_two/#dowhile-loop","text":"The do...while loop executes at least once, checking the condition after each iteration. int i = 3; do { printf(\"%d \", i); i++; } while (i < 4); // Output: 3","title":"do...while Loop"},{"location":"wk_two/#for-loop","text":"The for loop is used for iterations with a known number of repetitions, combining initialization, condition, and increment. for (int i = 0; i < 5; i++) { printf(\"%d \", i); } // Output: 0 1 2 3 4","title":"for Loop"},{"location":"wk_two/#pre-increment-vs-post-increment","text":"Pre-increment ( ++i ): Increments i before using its value. Post-increment ( i++ ): Uses i \u2019s value, then increments it. Example: int i = 0; printf(\"%d\\n\", i++); // Prints 0, then i becomes 1 printf(\"%d\\n\", ++i); // Increments i to 2, then prints 2 Bob's Preference: Use pre-increment ( ++i ) in loops for slight performance benefits (avoids creating a temporary copy) and clarity. In a for loop, the increment step (e.g., i++ or ++i in for (int i = 0; i < 5; i++) ) occurs after the loop body executes, so the choice of pre- or post-increment doesn\u2019t affect the loop\u2019s iteration behavior. Both produce the same sequence of loop iterations. However, within the loop body, the choice matters if the incremented value is used. For example, if you use i++ or ++i to modify another variable, the result differs.","title":"Pre-Increment vs. Post-Increment"},{"location":"wk_two/#loop-exit-conditions","text":"When using different increment types or loop structures, carefully consider when the loop exits: Integer increments: Ensure the condition accounts for the final value. int i = 0; while (i < 5) { printf(\"%d \", i); i += 2; // Increments by 2 } // Output: 0 2 4 Floating-point increments: Be cautious with floating-point conditions due to precision issues (basically, never do this). float i = 0.0; while (i < 1.0) { printf(\"%.1f \", i); i += 0.1; } // May not stop exactly at 1.0 due to floating-point imprecision","title":"Loop Exit Conditions"},{"location":"wk_two/#loop-type-choice","text":"Use while for condition-driven loops. Use do...while when at least one iteration is needed. Use for for counted loops with clear start and end points.","title":"Loop type choice:"},{"location":"wk_two/#casting-numbers","text":"When dividing two integers, the result is an integer, truncating any decimal part. To retain decimals, cast one or both operands to float or double . int a = 2, b = 3; float result = (float)a / b; // Cast a to float printf(\"%.2f\\n\", result); // %.2f formats to 2 decimal places // Output: 0.67 Note: Use %.nf in printf to specify n decimal places (e.g., %.2f for two decimals).","title":"Casting Numbers"},{"location":"wk_two/#arithmetic-overflow","text":"The <limits.h> header provides constraints for various types based on the underlying system limits. Example: #include <limits.h> #include <stdio.h> int main(void) { int x = INT_MAX; if (x > INT_MAX - 1) { // Check for overflow printf(\"Cannot increment without overflow\\n\"); } else { x++; } return 0; }","title":"Arithmetic Overflow"}]}