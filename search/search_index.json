{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"COMP2701 - Introduction to Procedural Programming with C Overview For full course information bcit.ca . Course taken in Spring 2025 ( outline ) with Bob Langelaan . Midterm and Final in-person 5 quizzes, one each in weeks 3, 5, 7, 9, and 11 right at the start of class midterm is also on week 7 There will be 4 assignments There are also optional leetcode exercises","title":"Home"},{"location":"#comp2701-introduction-to-procedural-programming-with-c","text":"","title":"COMP2701 - Introduction to Procedural Programming with C"},{"location":"#overview","text":"For full course information bcit.ca . Course taken in Spring 2025 ( outline ) with Bob Langelaan . Midterm and Final in-person 5 quizzes, one each in weeks 3, 5, 7, 9, and 11 right at the start of class midterm is also on week 7 There will be 4 assignments There are also optional leetcode exercises","title":"Overview"},{"location":"midterm/","text":"Midterm Review Summary Six Phases of C Program Development Editing/Programming : Write source code. Preprocess : Handle directives like #include (copies file contents) and #define (text replacement). Compile : Check syntax, generate .o object files with machine code. Link : Combine .o files and C library into an executable. Load : OS loads executable into memory. Execute : CPU runs program starting from main() . Main Function Every C program requires a main() function. #include <stdio.h> int main(void) { printf(\"Hello World\\n\"); return 0; } Variables Statically Typed : Declare type before use (e.g., int , float , char ). Naming Rules : Start with letter/underscore, use letters/digits/underscores. int a = 3; float b = 5.5; char c = 'A'; Preprocessor Directives #include : Import library functions (e.g., #include <stdio.h> ). #define : Define constants to avoid magic numbers. #define MAX 100 for(int i = 0; i < MAX; ++i) { ... } Input/Output Output : puts() : Prints string with automatic newline. printf() : Uses format specifiers ( %d , %c , %f ) for dynamic output, no automatic newline. printf(\"You entered %d.\\n\", number); Input : scanf() : Reads input with format specifiers, requires variable address ( & ) except for strings. int num; scanf(\"%d\", &num); char name[20]; scanf(\"%19s\", name); // No & for strings Operators Arithmetic : + , - , * , / , % (modulus for integers, integer division truncates). Casting : Convert types for precision. float result = (float)2 / 3; // 0.67 printf(\"%.2f\\n\", result); Assignment : = , += , -= , *= , /= , %= . Comparison : == , != , < , > , <= , >= (return 1 or 0). Logical : && (AND), || (OR), ! (NOT), uses short-circuit evaluation. Algorithms Procedure for solving a problem with actions to execute and execution order of those actions (program control). Control Structures Sequence : Statements execute in order. Selection : if , if...else , switch : Choose based on condition. Ternary Operator ( ?: ): Concise if...else . puts(x > 0 ? \"good\" : \"bad\"); Iteration : for , while , do...while : Repeat until condition met. Increment/Decrement Pre-increment ( ++x ): Increment first. Post-increment ( x++ ): Use, then increment. Use pre-increment in loops: for(int i = 0; i < 10; ++i) { ... } Functions Self-contained code for specific tasks. They help: Divide and Conquer : Build programs from reusable parts. Abstraction : Hide implementation details behind function names. Decomposition : Break complex problems into smaller functions. Structure : main() delegates tasks to helper functions. Function Definition return_type function_name(parameters) { statements } Example : int square(int number) { return number * number; } Function Prototype Do to C being sequential, we must declare function before use to avoid errors. A prototype allows us to declare a function up front and define it later. Example : int square(int); ... int square(int i) { return i*i; } Argument Coercion : Converts arguments to expected types; may cause data loss (e.g., double to int drops decimals). Function-Call Stack Stack : Last-in, first-out (LIFO) structure for function calls/returns. Behavior : Pushes frame with return address on call, pops on return. Risk : Stack overflow from excessive calls. Pass Arguments By Value : Copies argument; original unchanged. void superFunction(int num) { num *= 1000; } // No effect on original By Reference : Use pointers in C to modify original. Random-Number Generation From <stdlib.h> : rand() : Returns a number between 0 and RAND_MAX (\u226532,767). srand(seed) : Sets seed. Use mod % and the number of values your range is in. Offset it as needed. int dice = 1 + (rand() % 6); // 1 to 6 Use srand(time(NULL)) for unique sequences. Enumerated Types Programmer-defined types listing all valid values. Syntax : enum DaysOfWeek {SUN, MON, TUES, WED, THU, FRI, SAT}; enum DaysOfWeek today = MON; // Assigns 1 Values : Default starts at 0, increments by 1; can set explicit values. enum Status {CONTINUE = 0, WON = 1, LOST = 2}; Storage Classes Define variable attributes: storage duration (lifetime), scope (visibility), linkage (file access). auto : Default for local variables; stored on stack (rarely used explicitly). register : Requests CPU register storage (mostly obsolete; ignored by modern compilers). static : Persistent lifetime; local retains value between calls, global restricts to file. extern : Declares variable/function in another file; no storage created. Scope Function Scope : Labels (e.g., goto , switch ) visible in function. File Scope : Global variables, function prototypes outside functions; visible from declaration to file end. Block Scope : Variables in {} ; inner blocks can hide outer names (avoid this). Function-Prototype Scope : Parameter names in prototypes (optional, ignored by compiler). Memory Regions Stack : Automatic variables; allocated/deallocated with block scope. Static : Global/static local variables; persist entire program, initialized once. Heap : Dynamic memory (via malloc() , calloc() , realloc() ); manually managed. The Heap vs. A Heap : The Heap : Memory pool for dynamic allocation; no order. A Heap : Ordered tree-based data structure (e.g., min/max heap). Arrays Group of same-type elements stored contiguously in memory. Use array name with 0-based index to access an element (e.g., my_array[3] for fourth element). int my_arr[3]; // Static size, cannot be resized Best Practice : Use #define for array size to avoid magic numbers. Looping : Use size_t for index in loops. for (size_t i = 0; i < 5; ++i) { n[i] = i; } Initializer Lists : int n[5] = {32, 27, 64, 18, 95}; // Sets values int n[5] = {0}; // Sets all to 0 Strings Array of char terminated by '\\0' (NUL). Declaration : char s1[] = \"hello\"; // Auto-sized, NUL added char s2[10] = \"hello\"; // Fixed size, must fit NUL char s3[] = {'h', 'e', 'l', 'l', 'o', '\\0'}; // Manual NUL Input : char buf[20]; scanf(\"%19s\", buf); // No & needed, size limits input Static vs Automatic Arrays Static Array : Single instance, persists entire program, initialized to 0. Automatic Array : New instance per function call, contains garbage unless initialized. static int s_arr[3]; // Persists, 0-initialized int a_arr[3]; // New each call, garbage values Passing an Array to a Function Syntax : Use array name without brackets (e.g., myFunc(myArr) ). Behavior : Passes pointer to first element; function modifies original array (pass by reference). Const Arrays : Use const to prevent modification (e.g., for searching). void searchArray(const int arr[], size_t size); Multi-Dimensional Arrays Arrays of arrays (e.g., 2D array like a spreadsheet). Indexing : First index is row, second is column (e.g., arr[row][col] ). Memory : Stored in row-major order (row by row) in contiguous 1D memory. Address formula: start_loc + (rowNum * numberOfColumns) + colNum . Initializer Lists : int arr[3][3] = {{0, 1, 2}, {3, 4, 5}, {6, 7, 8}}; // Readable int arr[3][3] = {0, 1, 2, 3, 4, 5, 6, 7, 8}; // Same memory layout Passing to Functions : Specify all dimensions except first (e.g., void printArray(int arr[][3], size_t nRows) ). Looping : Use descriptive indices (e.g., row , col ) instead of i , j . for (size_t row = 0; row < 3; ++row) { for (size_t col = 0; col < 3; ++col) { printf(\"%d \", arr[row][col]); } printf(\"\\n\"); } Variable-Length Arrays (VLAs) Arrays sized at runtime (e.g., int arr[size] where size is user input). Limitation : Not supported by all compilers; Bob says do not use in this course. Alternative : Use malloc() , calloc() , or realloc() for dynamic arrays.","title":"Midterm Review"},{"location":"midterm/#midterm-review-summary","text":"","title":"Midterm Review Summary"},{"location":"midterm/#six-phases-of-c-program-development","text":"Editing/Programming : Write source code. Preprocess : Handle directives like #include (copies file contents) and #define (text replacement). Compile : Check syntax, generate .o object files with machine code. Link : Combine .o files and C library into an executable. Load : OS loads executable into memory. Execute : CPU runs program starting from main() .","title":"Six Phases of C Program Development"},{"location":"midterm/#main-function","text":"Every C program requires a main() function. #include <stdio.h> int main(void) { printf(\"Hello World\\n\"); return 0; }","title":"Main Function"},{"location":"midterm/#variables","text":"Statically Typed : Declare type before use (e.g., int , float , char ). Naming Rules : Start with letter/underscore, use letters/digits/underscores. int a = 3; float b = 5.5; char c = 'A';","title":"Variables"},{"location":"midterm/#preprocessor-directives","text":"#include : Import library functions (e.g., #include <stdio.h> ). #define : Define constants to avoid magic numbers. #define MAX 100 for(int i = 0; i < MAX; ++i) { ... }","title":"Preprocessor Directives"},{"location":"midterm/#inputoutput","text":"Output : puts() : Prints string with automatic newline. printf() : Uses format specifiers ( %d , %c , %f ) for dynamic output, no automatic newline. printf(\"You entered %d.\\n\", number); Input : scanf() : Reads input with format specifiers, requires variable address ( & ) except for strings. int num; scanf(\"%d\", &num); char name[20]; scanf(\"%19s\", name); // No & for strings","title":"Input/Output"},{"location":"midterm/#operators","text":"Arithmetic : + , - , * , / , % (modulus for integers, integer division truncates). Casting : Convert types for precision. float result = (float)2 / 3; // 0.67 printf(\"%.2f\\n\", result); Assignment : = , += , -= , *= , /= , %= . Comparison : == , != , < , > , <= , >= (return 1 or 0). Logical : && (AND), || (OR), ! (NOT), uses short-circuit evaluation.","title":"Operators"},{"location":"midterm/#algorithms","text":"Procedure for solving a problem with actions to execute and execution order of those actions (program control).","title":"Algorithms"},{"location":"midterm/#control-structures","text":"Sequence : Statements execute in order. Selection : if , if...else , switch : Choose based on condition. Ternary Operator ( ?: ): Concise if...else . puts(x > 0 ? \"good\" : \"bad\"); Iteration : for , while , do...while : Repeat until condition met.","title":"Control Structures"},{"location":"midterm/#incrementdecrement","text":"Pre-increment ( ++x ): Increment first. Post-increment ( x++ ): Use, then increment. Use pre-increment in loops: for(int i = 0; i < 10; ++i) { ... }","title":"Increment/Decrement"},{"location":"midterm/#functions","text":"Self-contained code for specific tasks. They help: Divide and Conquer : Build programs from reusable parts. Abstraction : Hide implementation details behind function names. Decomposition : Break complex problems into smaller functions. Structure : main() delegates tasks to helper functions.","title":"Functions"},{"location":"midterm/#function-definition","text":"return_type function_name(parameters) { statements } Example : int square(int number) { return number * number; }","title":"Function Definition"},{"location":"midterm/#function-prototype","text":"Do to C being sequential, we must declare function before use to avoid errors. A prototype allows us to declare a function up front and define it later. Example : int square(int); ... int square(int i) { return i*i; } Argument Coercion : Converts arguments to expected types; may cause data loss (e.g., double to int drops decimals).","title":"Function Prototype"},{"location":"midterm/#function-call-stack","text":"Stack : Last-in, first-out (LIFO) structure for function calls/returns. Behavior : Pushes frame with return address on call, pops on return. Risk : Stack overflow from excessive calls.","title":"Function-Call Stack"},{"location":"midterm/#pass-arguments","text":"By Value : Copies argument; original unchanged. void superFunction(int num) { num *= 1000; } // No effect on original By Reference : Use pointers in C to modify original.","title":"Pass Arguments"},{"location":"midterm/#random-number-generation","text":"From <stdlib.h> : rand() : Returns a number between 0 and RAND_MAX (\u226532,767). srand(seed) : Sets seed. Use mod % and the number of values your range is in. Offset it as needed. int dice = 1 + (rand() % 6); // 1 to 6 Use srand(time(NULL)) for unique sequences.","title":"Random-Number Generation"},{"location":"midterm/#enumerated-types","text":"Programmer-defined types listing all valid values. Syntax : enum DaysOfWeek {SUN, MON, TUES, WED, THU, FRI, SAT}; enum DaysOfWeek today = MON; // Assigns 1 Values : Default starts at 0, increments by 1; can set explicit values. enum Status {CONTINUE = 0, WON = 1, LOST = 2};","title":"Enumerated Types"},{"location":"midterm/#storage-classes","text":"Define variable attributes: storage duration (lifetime), scope (visibility), linkage (file access). auto : Default for local variables; stored on stack (rarely used explicitly). register : Requests CPU register storage (mostly obsolete; ignored by modern compilers). static : Persistent lifetime; local retains value between calls, global restricts to file. extern : Declares variable/function in another file; no storage created.","title":"Storage Classes"},{"location":"midterm/#scope","text":"Function Scope : Labels (e.g., goto , switch ) visible in function. File Scope : Global variables, function prototypes outside functions; visible from declaration to file end. Block Scope : Variables in {} ; inner blocks can hide outer names (avoid this). Function-Prototype Scope : Parameter names in prototypes (optional, ignored by compiler).","title":"Scope"},{"location":"midterm/#memory-regions","text":"Stack : Automatic variables; allocated/deallocated with block scope. Static : Global/static local variables; persist entire program, initialized once. Heap : Dynamic memory (via malloc() , calloc() , realloc() ); manually managed. The Heap vs. A Heap : The Heap : Memory pool for dynamic allocation; no order. A Heap : Ordered tree-based data structure (e.g., min/max heap).","title":"Memory Regions"},{"location":"midterm/#arrays","text":"Group of same-type elements stored contiguously in memory. Use array name with 0-based index to access an element (e.g., my_array[3] for fourth element). int my_arr[3]; // Static size, cannot be resized Best Practice : Use #define for array size to avoid magic numbers. Looping : Use size_t for index in loops. for (size_t i = 0; i < 5; ++i) { n[i] = i; } Initializer Lists : int n[5] = {32, 27, 64, 18, 95}; // Sets values int n[5] = {0}; // Sets all to 0","title":"Arrays"},{"location":"midterm/#strings","text":"Array of char terminated by '\\0' (NUL). Declaration : char s1[] = \"hello\"; // Auto-sized, NUL added char s2[10] = \"hello\"; // Fixed size, must fit NUL char s3[] = {'h', 'e', 'l', 'l', 'o', '\\0'}; // Manual NUL Input : char buf[20]; scanf(\"%19s\", buf); // No & needed, size limits input","title":"Strings"},{"location":"midterm/#static-vs-automatic-arrays","text":"Static Array : Single instance, persists entire program, initialized to 0. Automatic Array : New instance per function call, contains garbage unless initialized. static int s_arr[3]; // Persists, 0-initialized int a_arr[3]; // New each call, garbage values","title":"Static vs Automatic Arrays"},{"location":"midterm/#passing-an-array-to-a-function","text":"Syntax : Use array name without brackets (e.g., myFunc(myArr) ). Behavior : Passes pointer to first element; function modifies original array (pass by reference). Const Arrays : Use const to prevent modification (e.g., for searching). void searchArray(const int arr[], size_t size);","title":"Passing an Array to a Function"},{"location":"midterm/#multi-dimensional-arrays","text":"Arrays of arrays (e.g., 2D array like a spreadsheet). Indexing : First index is row, second is column (e.g., arr[row][col] ). Memory : Stored in row-major order (row by row) in contiguous 1D memory. Address formula: start_loc + (rowNum * numberOfColumns) + colNum . Initializer Lists : int arr[3][3] = {{0, 1, 2}, {3, 4, 5}, {6, 7, 8}}; // Readable int arr[3][3] = {0, 1, 2, 3, 4, 5, 6, 7, 8}; // Same memory layout Passing to Functions : Specify all dimensions except first (e.g., void printArray(int arr[][3], size_t nRows) ). Looping : Use descriptive indices (e.g., row , col ) instead of i , j . for (size_t row = 0; row < 3; ++row) { for (size_t col = 0; col < 3; ++col) { printf(\"%d \", arr[row][col]); } printf(\"\\n\"); }","title":"Multi-Dimensional Arrays"},{"location":"midterm/#variable-length-arrays-vlas","text":"Arrays sized at runtime (e.g., int arr[size] where size is user input). Limitation : Not supported by all compilers; Bob says do not use in this course. Alternative : Use malloc() , calloc() , or realloc() for dynamic arrays.","title":"Variable-Length Arrays (VLAs)"},{"location":"wk_five/","text":"Week 5 Arrays Arrays are data structures consisting of related data items of the same type. More specifically, an array is a group of elements of the same type stored contiguously in memory. Accessing Elements of an Array To access an element we specify the array name followed by a position number in [] . This position number is also known as a subscript or index . The index is 0-based so my_array[3] will be the fourth element of my_array . Defining an Array To define an array, we specify the type of the array followed by the number of elements that will be in the array in [] . For example, int my_arr[3]; will reserve a space that is 3 ints wide in memory and assign it the label my_arr. In C arrays are static entities meaning that they remain the same size throughout their lifetimes. That is, they can't be resized. Note: in general we should use a #define statement for the size of an array so that we can avoid using magic numbers Looping over an Array. When looping over an array, it is recommended to use a size_t type for the counter control variable. #include <stdio.h> int main(void) { for (size_t i = 0; i < 5; ++i) { n[i] = i; } } Initializer Lists We can define an array with an initializer list to set all the elements to specific values. int n[5] = {32, 27, 64, 18, 95} will set n[0] to 32, n[1] to 27, etc. The size of the initializer list does not need to be as large as the array. Any elements that are not specified will be set to 0. int n[5] = {0}; is equivalent to int n[5] = {0,0,0,0,0} . Strings A string in C is an array of char, terminated by a NUL character '\\0' (ASCII 0). As a side note - an array of char does not necessarily need to be a string but a string is always and array of char. There are a few ways to define a string: // 1. String literal \u2014 auto-size, NUL added char s1[] = \"hello\"; // 2. Fixed-size array with string literal \u2014 NUL added, extra space unused char s2[10] = \"hello\"; // 3. Character array with initializer list \u2014 must manually add '\\0' char s3[] = { 'h', 'e', 'l', 'l', 'o', '\\0' }; Note: for s2 style of defining a string, where we define the size we must always make sure that the size can accommodate the '\\0' at the end. char s2[5] = \"hello\" would be invalid because all 5 spaces would be used up. String Input When we want to grab input from the user, we can define a fixed size buffer array to store the string in and then use a size format specifier to make sure we do not exceed the size of the buffer. char buf[20]; scanf(\"%19s\", buf); // note that we don't add the & here that we // normally do in scanf because buf is an array // and is already a pointer Static vs Automatic Arrays Recall that static, similar to Java, means that something is only ever initialized once during a program call. Every time its referred to by a function thereafter, it refers to that single instance. This is in contrast to the default (automatic) array. Every time an automatic array initialized by a function it is a new instance of that array and is destroyed after we exit the function. static int s_arr[3]; // keeps values between calls - initialized to 0 by default int a_arr[3]; // new array each time \u2014 garbage values until initialized Type Lifetime Initialized to static array Entire program 0 (by default) automatic array Each function call Garbage (unless explicit)","title":"Week 5"},{"location":"wk_five/#week-5","text":"","title":"Week 5"},{"location":"wk_five/#arrays","text":"Arrays are data structures consisting of related data items of the same type. More specifically, an array is a group of elements of the same type stored contiguously in memory.","title":"Arrays"},{"location":"wk_five/#accessing-elements-of-an-array","text":"To access an element we specify the array name followed by a position number in [] . This position number is also known as a subscript or index . The index is 0-based so my_array[3] will be the fourth element of my_array .","title":"Accessing Elements of an Array"},{"location":"wk_five/#defining-an-array","text":"To define an array, we specify the type of the array followed by the number of elements that will be in the array in [] . For example, int my_arr[3]; will reserve a space that is 3 ints wide in memory and assign it the label my_arr. In C arrays are static entities meaning that they remain the same size throughout their lifetimes. That is, they can't be resized. Note: in general we should use a #define statement for the size of an array so that we can avoid using magic numbers","title":"Defining an Array"},{"location":"wk_five/#looping-over-an-array","text":"When looping over an array, it is recommended to use a size_t type for the counter control variable. #include <stdio.h> int main(void) { for (size_t i = 0; i < 5; ++i) { n[i] = i; } }","title":"Looping over an Array."},{"location":"wk_five/#initializer-lists","text":"We can define an array with an initializer list to set all the elements to specific values. int n[5] = {32, 27, 64, 18, 95} will set n[0] to 32, n[1] to 27, etc. The size of the initializer list does not need to be as large as the array. Any elements that are not specified will be set to 0. int n[5] = {0}; is equivalent to int n[5] = {0,0,0,0,0} .","title":"Initializer Lists"},{"location":"wk_five/#strings","text":"A string in C is an array of char, terminated by a NUL character '\\0' (ASCII 0). As a side note - an array of char does not necessarily need to be a string but a string is always and array of char. There are a few ways to define a string: // 1. String literal \u2014 auto-size, NUL added char s1[] = \"hello\"; // 2. Fixed-size array with string literal \u2014 NUL added, extra space unused char s2[10] = \"hello\"; // 3. Character array with initializer list \u2014 must manually add '\\0' char s3[] = { 'h', 'e', 'l', 'l', 'o', '\\0' }; Note: for s2 style of defining a string, where we define the size we must always make sure that the size can accommodate the '\\0' at the end. char s2[5] = \"hello\" would be invalid because all 5 spaces would be used up.","title":"Strings"},{"location":"wk_five/#string-input","text":"When we want to grab input from the user, we can define a fixed size buffer array to store the string in and then use a size format specifier to make sure we do not exceed the size of the buffer. char buf[20]; scanf(\"%19s\", buf); // note that we don't add the & here that we // normally do in scanf because buf is an array // and is already a pointer","title":"String Input"},{"location":"wk_five/#static-vs-automatic-arrays","text":"Recall that static, similar to Java, means that something is only ever initialized once during a program call. Every time its referred to by a function thereafter, it refers to that single instance. This is in contrast to the default (automatic) array. Every time an automatic array initialized by a function it is a new instance of that array and is destroyed after we exit the function. static int s_arr[3]; // keeps values between calls - initialized to 0 by default int a_arr[3]; // new array each time \u2014 garbage values until initialized Type Lifetime Initialized to static array Entire program 0 (by default) automatic array Each function call Garbage (unless explicit)","title":"Static vs Automatic Arrays"},{"location":"wk_four/","text":"Week 4 Enumerated Types Enumerated types are types created by the programmer themselves. They enumerate all the legal values that can be assigned to a variable of that type. enum DaysOfWeek {SUN, MON, TUES, WED, THU, FRI, SAT}; enum DaysOfWeek today = MON; // will assign 1 to today Example: Click to show code #include <stdio.h> enum DaysOfWeek { SUN, MON, TUES, WED, THU, FRI, SAT }; const char *day_name(enum DaysOfWeek day) { switch (day) { case SUN: return \"Sunday\"; case MON: return \"Monday\"; case TUES: return \"Tuesday\"; case WED: return \"Wednesday\"; case THU: return \"Thursday\"; case FRI: return \"Friday\"; case SAT: return \"Saturday\"; default: return \"Invalid\"; } } int main(void) { printf(\"All days of the week:\\n\"); for (enum DaysOfWeek d = SUN; d <= SAT; ++d) { printf(\"%d = %s\\n\", d, day_name(d)); } return 0; } By default, the first name is assigned the integer value 0, and each subsequent name increases by 1. We can also explicitly set values. enum Status {CONTINUE = 0, WON = 1, LOST = 2}; Storage Classes Variables have other attributes beside the name , type , size and value . One such is the storage class specifier which we will go into below. The storage class specifier is used to determine the following other attributes: storage duration (when it exists in memory), scope (where a program can reference the identifier), and linkage (whether it is known only in the current file or in any source) for the identifier. C has the following storage class specifiers : auto This is the default for local (block-scope) variables. It tells the compiler to store the variable in automatic storage (i.e., on the stack). It's largely redundant in modern C and rarely written explicitly. register This was used to request that a variable be stored in a CPU register for faster access. You cannot get the address of a register variable using & . Modern compilers ignore it and optimize register usage themselves, so this is now mostly obsolete. static Gives a variable static storage duration \u2013 it exists for the lifetime of the program, even if defined inside a function. Two main uses: Static local variables : retain their value between function calls. Static global variables/functions : restrict visibility to the current translation unit (file) \u2013 no external linkage. extern Tells the compiler that a global variable or function exists in another file. It does not create storage; it just declares the identifier so it can be used. Common use: declare a global variable defined in another .c file. Scope The scope of an identifier is the portion of the program in which that identifier can be referenced. In C there are four identifier scopes: function scope Applies only to labels (e.g., start: ) used with goto and switch statements. Labels are visible anywhere in the function where they're defined, but note outside it. They support information hiding, aligning with the principle of least privilege : only grant access needed for a specific task. file scope Applies to identifiers declared outside any function. Visibility spans from the point of declaration to the end of the file. Examples: Global variables Function prototypes Function definitions outside functions block scope Applies to identifiers declared inside a block (between { and } ). Blocks can nest , and inner blocks can hide outer block identifiers with the same name \u2014 generally best to avoid name hiding. static local variables still have block scope (but static storage duration). function-prototype scope Applies only to parameter names in function prototypes - within the () of a prototype These names are optional and ignored by the compiler \u2014 only types matter. Memory Regions Overview Before we move on, it's useful to understand where variables actually live in memory. The location affects how long they last, how they're accessed, and how they're cleaned up. Stack Static Heap Automatic Variables Global Variables Dynamic Variables* Static Local Variables *dynamic variables are created with malloc() , calloc() , and realloc() . Stack: Fast allocation/deallocation; tied to block scope. Stack variables are automatically deallocated when their scope ends. Static: Persistent for the program\u2019s lifetime; only initialized once. Heap: Used for dynamic memory; you manage it explicitly. The Heap vs. A Heap The term heap can refer to two separate concepts in programming \u2014 one related to memory, the other to data structures and algorithms. The heap (memory region): A section of memory used for dynamic allocation. Variables stored here persist until manually deallocated (e.g., with free() in C). No ordering \u2014 not FIFO, not LIFO. It's just a pool of memory. A heap (data structure): A type of tree-based structure (e.g., min-heap or max-heap) used for priority queues. Has ordering rules (e.g., smallest or largest item always on top), but unrelated to memory allocation.","title":"Week 4"},{"location":"wk_four/#week-4","text":"","title":"Week 4"},{"location":"wk_four/#enumerated-types","text":"Enumerated types are types created by the programmer themselves. They enumerate all the legal values that can be assigned to a variable of that type. enum DaysOfWeek {SUN, MON, TUES, WED, THU, FRI, SAT}; enum DaysOfWeek today = MON; // will assign 1 to today Example: Click to show code #include <stdio.h> enum DaysOfWeek { SUN, MON, TUES, WED, THU, FRI, SAT }; const char *day_name(enum DaysOfWeek day) { switch (day) { case SUN: return \"Sunday\"; case MON: return \"Monday\"; case TUES: return \"Tuesday\"; case WED: return \"Wednesday\"; case THU: return \"Thursday\"; case FRI: return \"Friday\"; case SAT: return \"Saturday\"; default: return \"Invalid\"; } } int main(void) { printf(\"All days of the week:\\n\"); for (enum DaysOfWeek d = SUN; d <= SAT; ++d) { printf(\"%d = %s\\n\", d, day_name(d)); } return 0; } By default, the first name is assigned the integer value 0, and each subsequent name increases by 1. We can also explicitly set values. enum Status {CONTINUE = 0, WON = 1, LOST = 2};","title":"Enumerated Types"},{"location":"wk_four/#storage-classes","text":"Variables have other attributes beside the name , type , size and value . One such is the storage class specifier which we will go into below. The storage class specifier is used to determine the following other attributes: storage duration (when it exists in memory), scope (where a program can reference the identifier), and linkage (whether it is known only in the current file or in any source) for the identifier. C has the following storage class specifiers : auto This is the default for local (block-scope) variables. It tells the compiler to store the variable in automatic storage (i.e., on the stack). It's largely redundant in modern C and rarely written explicitly. register This was used to request that a variable be stored in a CPU register for faster access. You cannot get the address of a register variable using & . Modern compilers ignore it and optimize register usage themselves, so this is now mostly obsolete. static Gives a variable static storage duration \u2013 it exists for the lifetime of the program, even if defined inside a function. Two main uses: Static local variables : retain their value between function calls. Static global variables/functions : restrict visibility to the current translation unit (file) \u2013 no external linkage. extern Tells the compiler that a global variable or function exists in another file. It does not create storage; it just declares the identifier so it can be used. Common use: declare a global variable defined in another .c file.","title":"Storage Classes"},{"location":"wk_four/#scope","text":"The scope of an identifier is the portion of the program in which that identifier can be referenced. In C there are four identifier scopes: function scope Applies only to labels (e.g., start: ) used with goto and switch statements. Labels are visible anywhere in the function where they're defined, but note outside it. They support information hiding, aligning with the principle of least privilege : only grant access needed for a specific task. file scope Applies to identifiers declared outside any function. Visibility spans from the point of declaration to the end of the file. Examples: Global variables Function prototypes Function definitions outside functions block scope Applies to identifiers declared inside a block (between { and } ). Blocks can nest , and inner blocks can hide outer block identifiers with the same name \u2014 generally best to avoid name hiding. static local variables still have block scope (but static storage duration). function-prototype scope Applies only to parameter names in function prototypes - within the () of a prototype These names are optional and ignored by the compiler \u2014 only types matter.","title":"Scope"},{"location":"wk_four/#memory-regions-overview","text":"Before we move on, it's useful to understand where variables actually live in memory. The location affects how long they last, how they're accessed, and how they're cleaned up. Stack Static Heap Automatic Variables Global Variables Dynamic Variables* Static Local Variables *dynamic variables are created with malloc() , calloc() , and realloc() . Stack: Fast allocation/deallocation; tied to block scope. Stack variables are automatically deallocated when their scope ends. Static: Persistent for the program\u2019s lifetime; only initialized once. Heap: Used for dynamic memory; you manage it explicitly.","title":"Memory Regions Overview"},{"location":"wk_four/#the-heap-vs-a-heap","text":"The term heap can refer to two separate concepts in programming \u2014 one related to memory, the other to data structures and algorithms.","title":"The Heap vs. A Heap"},{"location":"wk_four/#the-heap-memory-region","text":"A section of memory used for dynamic allocation. Variables stored here persist until manually deallocated (e.g., with free() in C). No ordering \u2014 not FIFO, not LIFO. It's just a pool of memory.","title":"The heap (memory region):"},{"location":"wk_four/#a-heap-data-structure","text":"A type of tree-based structure (e.g., min-heap or max-heap) used for priority queues. Has ordering rules (e.g., smallest or largest item always on top), but unrelated to memory allocation.","title":"A heap (data structure):"},{"location":"wk_one/","text":"Week 1 Week 1 focused on the basics of C: what it is, how a C program is built and run, and how we interact with it using functions like main() , printf() , and scanf() . What is C C is a language evolved from BCPL and B language. It became popular on Unix systems which were among the first hardware agnostic OS. C is used for highly performant programs because it is quite efficient. C is widely used in operating systems (e.g., Linux kernel), embedded systems, and as a foundation for languages like C++ and Java. C does not have any objects. That means we only have functions to use to structure our programs. C Development There are typically six phases of a program in C: editing/programming preprocess These are commands that will change the code that you write examples are #include and #define back in the day, there were no mice to copy and paste things and the terminals were dumb (brains were in the mainframe) so it was difficult to copy and paste things. preprocessor allows you to do things similar to a copy and paste. for #include , think of it like copying and pasting the contents of the included file into this one. for #define , think of it like a text replacement in our code. compile catches syntax errors creates machine code from your code into .o files link combines the .o files and the C Library Object Code into an executable load The operating system loads the executable into memory, preparing it for execution. execute The CPU runs the program, starting from the main function. main Function In C programs begin execution in the main() function. The basic syntax is: int main(void) { // ... do stuff } In modern C (C99 and later), main() implicitly returns 0 if no return statement is given. This only applies to main() \u2014 all other functions require an explicit return if they are non-void. 0 indicates success 1 or any positive int up to 255 signifies an error. We can see the returned value in the terminal by typing: echo $? We can also take command line arguments in main with the following syntax: int main(int argc, char *argv[]) // OR int main(int argc char **argv) Example with CLI arguments In this example, we take in a command line argument along with the function call. The program ends by listing the argument index and the argument value to highlight that the first argument is always the name of the program: #include <stdio.h> // we need to include stdio to get access to puts() and printf() funtions. #include <stdlib.h> // for EXIT_FAILURE and EXIT_SUCCESS macros int main(int argc, char *argv[]) { if (argc != 2) { puts(\"Usage: ./hello_2 <input_name>\"); return EXIT_FAILURE; // EXIT_FAILURE evaluates to 1 and is more portable than hardcoding the value } printf(\"Hello, %s\\n\", argv[1]); puts(\"Welcome to COMP2701\\n\"); puts(\"Here are the arguments that were supplied:\"); for (int i = 0; i < argc; i++) { printf(\"%3d %10s\\n\", i, argv[i]); } puts(\"\"); return EXIT_SUCCESS;// EXIT_SUCCESS evaluates to 0 } Printing Output In C, functions like printf() and puts() are used to print output to the screen. Unlike Python or Java, these functions aren\u2019t available by default \u2014 you must include the appropriate header file first. For both printf() and puts() , that file is <stdio.h> (standard I/O). To use them, simply add #include <stdio.h> at the top of your program. puts() puts() prints out strictly a string of text. We cannot pass any variables into the string. puts() automatically appends a newline character to the end of the string. printf() printf() (or print f ormatted) prints out a formatted string where, like python and Java, we can pass in variables. Unlike puts() , printf() does not append a newline character. We must end the string with \\n if we want a new line. In order to use variables in a printf() statement, we must pass in a string with placeholder format specifiers followed by a list of the variables to place in the specifiers. int i = 10; printf(\"The value of i is %d.\\n\", i); // The value of i is 10. printf() Format Specifiers The following is a list of some common format specifiers: Specifier Description Example Output Data Type %d Signed decimal integer 42 int %i Signed decimal integer (same as %d ) 42 int %u Unsigned decimal integer 42 unsigned int %zu Unsigned size of objects in bytes 42 size_t %f Decimal floating point 3.141593 float , double %F Decimal floating point (uppercase INF/NAN ) 3.141593 float , double %c Single character A char %s String of characters Hello char * %p Pointer address 0x7ffeefbff5c0 void * %% Literal % character % \u2014 Getting User Input In C there are a few ways to get user input. For our purposes, we will be using scanf() in this course. As with the printing functions, scanf() is found in the <stdio.h> library so make sure to include that in programs that will use scanf() . int number = 0; printf(\"Please enter a number: \"); if (scanf(\"%d\", &number) != 1) { printf(\"Invalid input!\\n\"); return 1; } printf(\"You entered %d.\\n\", number); // Please enter a number: 10 // You entered 10. Unlike printf() and puts() , scanf() requires the address of variables (e.g., &number in the above example). This is because C passes variables by value, meaning a copy is passed unless the address is provided. Since scanf() is looking for a place to store the result, simply passing in the variable as usual would be pointless - we would be writing to a copy and not changing the result. Instead we give scanf() the address in memory where we would like to store the result. In practice, we generally want to prefix any variable that we are storing a result to with the address symbol & . The only time we don't need to do this is with arrays (which we will cover later in this course). Example of scanf() with an array: char name[20]; printf(\"Enter your name: \"); scanf(\"%19s\", name); // note: NO \"&\" here because a string is an array of chars. printf(\"Hello, %s!\\n\", name); scanf() Format Specifiers The next notable difference is that there are some slighlty different format specifiers in scanf() . Here is a summary of some of the main differences: Type printf scanf Why it matters double %f %lf Must use %lf in scanf float %f %f scanf(\"%f\") stores to float* only short %d %hd scanf needs h to downcast long %d or %ld %ld Same specifier, but required in scanf - printf can accept a long in %d but could overflow so not advised. long long %lld %lld Required for long long in both Other Gotchas In addition to needing addresses and the slightly different format specifiers, there are a few other behaviours worth noting. Character Input scanf(\"%c\", &ch) reads any character, including whitespace, which can cause issues due to leftover newlines in the input buffer. int x; char ch; scanf(\"%d\", &x); // user enters: 5\u23ce scanf(\"%c\", &ch); // reads \u23ce as the char! String Inputs scanf(\"%s\", str) reads input up to the first whitespace (space, tab, or newline). Because of this, using it without a width specifier is unsafe and risks a buffer overflow. In contrast, printf(\"%s\", str) will print the entire string until it sees the \\0 NUL character. char str[5]; scanf(\"%s\", str); // \u274c may overflow if input > 4 chars scanf(\"%4s\", str); // \u2705 safer (leaves 1 byte for '\\0') Note: What is a String in C? In C, a string is not a separate type \u2014 it's just an array of char values that ends with a NUL terminator ( '\\0' ). So when you write: char name[] = \"Alice\"; It\u2019s really just shorthand for: char name[] = { 'A', 'l', 'i', 'c', 'e', '\\0' }; That special '\\0' character tells functions like printf(\"%s\", name) where the string ends. Put another way, strings in C are really just arrays of characters with a rule: they must end in '\\0' . Unlike in Python, Java, or C++, there's no built-in \"string\" type \u2014 just arrays and pointers. Note: NUL vs NULL These look similar but serve very different purposes in C: Term Type Meaning NUL char ASCII character 0 (value 0x00 ) NULL pointer Null pointer constant (typically 0 or (void*)0 ) NUL ( '\\0' ) A character with value 0 Used to terminate C strings Equivalent to: char c = '\\0'; // or: char c = 0; NULL A macro that represents a null pointer constant Typically defined as ((void *)0) in <stddef.h> Used when a pointer doesn\u2019t point to a valid memory location. Example: int *ptr = NULL; if (ptr == NULL) { // pointer is uninitialized or empty } Note: What is a char in C? In C, a char is a fundamental data type that represents a single character, but at its core, it is simply an 8-bit integer (typically 1 byte) that can hold values from -128 to 127 (for signed char) or 0 to 255 (for unsigned char). These numeric values are often used to represent characters according to the ASCII table, where each number corresponds to a specific character. For example: The character 'A' has an ASCII value of 65. The character 'a' has an ASCII value of 97. The character '0' (the digit zero) has an ASCII value of 48. You can work with char values as either characters or numbers. For instance: char c = 'A'; // Stores the character 'A' (ASCII value 65) printf(\"%c\\n\", c); // Prints: A printf(\"%d\\n\", c); // Prints: 65 This dual nature of char allows you to perform arithmetic operations on characters. For example: char c = 'A'; c = c + 1; // Moves to the next ASCII value ('B' = 66) printf(\"%c\\n\", c); // Prints: B The ASCII table is critical for understanding how characters are represented in C. Common ASCII values include: Common ASCII Values Character ASCII Value Description 'A' 65 Uppercase A 'Z' 90 Uppercase Z 'a' 97 Lowercase a 'z' 122 Lowercase z '0' 48 Digit 0 '9' 57 Digit 9 ' ' 32 Space '\\n' 10 Newline '\\0' 0 NUL (string terminator) Lowercase and Uppercase letters are exactly 32 values away from the same letter When using char in strings or with input/output functions like printf() and scanf() , the ASCII encoding ensures that numeric values are interpreted as readable characters.","title":"Week 1"},{"location":"wk_one/#week-1","text":"Week 1 focused on the basics of C: what it is, how a C program is built and run, and how we interact with it using functions like main() , printf() , and scanf() .","title":"Week 1"},{"location":"wk_one/#what-is-c","text":"C is a language evolved from BCPL and B language. It became popular on Unix systems which were among the first hardware agnostic OS. C is used for highly performant programs because it is quite efficient. C is widely used in operating systems (e.g., Linux kernel), embedded systems, and as a foundation for languages like C++ and Java. C does not have any objects. That means we only have functions to use to structure our programs.","title":"What is C"},{"location":"wk_one/#c-development","text":"There are typically six phases of a program in C: editing/programming preprocess These are commands that will change the code that you write examples are #include and #define back in the day, there were no mice to copy and paste things and the terminals were dumb (brains were in the mainframe) so it was difficult to copy and paste things. preprocessor allows you to do things similar to a copy and paste. for #include , think of it like copying and pasting the contents of the included file into this one. for #define , think of it like a text replacement in our code. compile catches syntax errors creates machine code from your code into .o files link combines the .o files and the C Library Object Code into an executable load The operating system loads the executable into memory, preparing it for execution. execute The CPU runs the program, starting from the main function.","title":"C Development"},{"location":"wk_one/#main-function","text":"In C programs begin execution in the main() function. The basic syntax is: int main(void) { // ... do stuff } In modern C (C99 and later), main() implicitly returns 0 if no return statement is given. This only applies to main() \u2014 all other functions require an explicit return if they are non-void. 0 indicates success 1 or any positive int up to 255 signifies an error. We can see the returned value in the terminal by typing: echo $? We can also take command line arguments in main with the following syntax: int main(int argc, char *argv[]) // OR int main(int argc char **argv) Example with CLI arguments In this example, we take in a command line argument along with the function call. The program ends by listing the argument index and the argument value to highlight that the first argument is always the name of the program: #include <stdio.h> // we need to include stdio to get access to puts() and printf() funtions. #include <stdlib.h> // for EXIT_FAILURE and EXIT_SUCCESS macros int main(int argc, char *argv[]) { if (argc != 2) { puts(\"Usage: ./hello_2 <input_name>\"); return EXIT_FAILURE; // EXIT_FAILURE evaluates to 1 and is more portable than hardcoding the value } printf(\"Hello, %s\\n\", argv[1]); puts(\"Welcome to COMP2701\\n\"); puts(\"Here are the arguments that were supplied:\"); for (int i = 0; i < argc; i++) { printf(\"%3d %10s\\n\", i, argv[i]); } puts(\"\"); return EXIT_SUCCESS;// EXIT_SUCCESS evaluates to 0 }","title":"main Function"},{"location":"wk_one/#printing-output","text":"In C, functions like printf() and puts() are used to print output to the screen. Unlike Python or Java, these functions aren\u2019t available by default \u2014 you must include the appropriate header file first. For both printf() and puts() , that file is <stdio.h> (standard I/O). To use them, simply add #include <stdio.h> at the top of your program.","title":"Printing Output"},{"location":"wk_one/#puts","text":"puts() prints out strictly a string of text. We cannot pass any variables into the string. puts() automatically appends a newline character to the end of the string.","title":"puts()"},{"location":"wk_one/#printf","text":"printf() (or print f ormatted) prints out a formatted string where, like python and Java, we can pass in variables. Unlike puts() , printf() does not append a newline character. We must end the string with \\n if we want a new line. In order to use variables in a printf() statement, we must pass in a string with placeholder format specifiers followed by a list of the variables to place in the specifiers. int i = 10; printf(\"The value of i is %d.\\n\", i); // The value of i is 10.","title":"printf()"},{"location":"wk_one/#printf-format-specifiers","text":"The following is a list of some common format specifiers: Specifier Description Example Output Data Type %d Signed decimal integer 42 int %i Signed decimal integer (same as %d ) 42 int %u Unsigned decimal integer 42 unsigned int %zu Unsigned size of objects in bytes 42 size_t %f Decimal floating point 3.141593 float , double %F Decimal floating point (uppercase INF/NAN ) 3.141593 float , double %c Single character A char %s String of characters Hello char * %p Pointer address 0x7ffeefbff5c0 void * %% Literal % character % \u2014","title":"printf() Format Specifiers"},{"location":"wk_one/#getting-user-input","text":"In C there are a few ways to get user input. For our purposes, we will be using scanf() in this course. As with the printing functions, scanf() is found in the <stdio.h> library so make sure to include that in programs that will use scanf() . int number = 0; printf(\"Please enter a number: \"); if (scanf(\"%d\", &number) != 1) { printf(\"Invalid input!\\n\"); return 1; } printf(\"You entered %d.\\n\", number); // Please enter a number: 10 // You entered 10. Unlike printf() and puts() , scanf() requires the address of variables (e.g., &number in the above example). This is because C passes variables by value, meaning a copy is passed unless the address is provided. Since scanf() is looking for a place to store the result, simply passing in the variable as usual would be pointless - we would be writing to a copy and not changing the result. Instead we give scanf() the address in memory where we would like to store the result. In practice, we generally want to prefix any variable that we are storing a result to with the address symbol & . The only time we don't need to do this is with arrays (which we will cover later in this course). Example of scanf() with an array: char name[20]; printf(\"Enter your name: \"); scanf(\"%19s\", name); // note: NO \"&\" here because a string is an array of chars. printf(\"Hello, %s!\\n\", name);","title":"Getting User Input"},{"location":"wk_one/#scanf-format-specifiers","text":"The next notable difference is that there are some slighlty different format specifiers in scanf() . Here is a summary of some of the main differences: Type printf scanf Why it matters double %f %lf Must use %lf in scanf float %f %f scanf(\"%f\") stores to float* only short %d %hd scanf needs h to downcast long %d or %ld %ld Same specifier, but required in scanf - printf can accept a long in %d but could overflow so not advised. long long %lld %lld Required for long long in both","title":"scanf() Format Specifiers"},{"location":"wk_one/#other-gotchas","text":"In addition to needing addresses and the slightly different format specifiers, there are a few other behaviours worth noting.","title":"Other Gotchas"},{"location":"wk_one/#character-input","text":"scanf(\"%c\", &ch) reads any character, including whitespace, which can cause issues due to leftover newlines in the input buffer. int x; char ch; scanf(\"%d\", &x); // user enters: 5\u23ce scanf(\"%c\", &ch); // reads \u23ce as the char!","title":"Character Input"},{"location":"wk_one/#string-inputs","text":"scanf(\"%s\", str) reads input up to the first whitespace (space, tab, or newline). Because of this, using it without a width specifier is unsafe and risks a buffer overflow. In contrast, printf(\"%s\", str) will print the entire string until it sees the \\0 NUL character. char str[5]; scanf(\"%s\", str); // \u274c may overflow if input > 4 chars scanf(\"%4s\", str); // \u2705 safer (leaves 1 byte for '\\0')","title":"String Inputs"},{"location":"wk_one/#note-what-is-a-string-in-c","text":"In C, a string is not a separate type \u2014 it's just an array of char values that ends with a NUL terminator ( '\\0' ). So when you write: char name[] = \"Alice\"; It\u2019s really just shorthand for: char name[] = { 'A', 'l', 'i', 'c', 'e', '\\0' }; That special '\\0' character tells functions like printf(\"%s\", name) where the string ends. Put another way, strings in C are really just arrays of characters with a rule: they must end in '\\0' . Unlike in Python, Java, or C++, there's no built-in \"string\" type \u2014 just arrays and pointers.","title":"Note: What is a String in C?"},{"location":"wk_one/#note-nul-vs-null","text":"These look similar but serve very different purposes in C: Term Type Meaning NUL char ASCII character 0 (value 0x00 ) NULL pointer Null pointer constant (typically 0 or (void*)0 )","title":"Note: NUL vs NULL"},{"location":"wk_one/#nul-0","text":"A character with value 0 Used to terminate C strings Equivalent to: char c = '\\0'; // or: char c = 0;","title":"NUL ('\\0')"},{"location":"wk_one/#null","text":"A macro that represents a null pointer constant Typically defined as ((void *)0) in <stddef.h> Used when a pointer doesn\u2019t point to a valid memory location. Example: int *ptr = NULL; if (ptr == NULL) { // pointer is uninitialized or empty }","title":"NULL"},{"location":"wk_one/#note-what-is-a-char-in-c","text":"In C, a char is a fundamental data type that represents a single character, but at its core, it is simply an 8-bit integer (typically 1 byte) that can hold values from -128 to 127 (for signed char) or 0 to 255 (for unsigned char). These numeric values are often used to represent characters according to the ASCII table, where each number corresponds to a specific character. For example: The character 'A' has an ASCII value of 65. The character 'a' has an ASCII value of 97. The character '0' (the digit zero) has an ASCII value of 48. You can work with char values as either characters or numbers. For instance: char c = 'A'; // Stores the character 'A' (ASCII value 65) printf(\"%c\\n\", c); // Prints: A printf(\"%d\\n\", c); // Prints: 65 This dual nature of char allows you to perform arithmetic operations on characters. For example: char c = 'A'; c = c + 1; // Moves to the next ASCII value ('B' = 66) printf(\"%c\\n\", c); // Prints: B The ASCII table is critical for understanding how characters are represented in C. Common ASCII values include:","title":"Note: What is a char in C?"},{"location":"wk_one/#common-ascii-values","text":"Character ASCII Value Description 'A' 65 Uppercase A 'Z' 90 Uppercase Z 'a' 97 Lowercase a 'z' 122 Lowercase z '0' 48 Digit 0 '9' 57 Digit 9 ' ' 32 Space '\\n' 10 Newline '\\0' 0 NUL (string terminator) Lowercase and Uppercase letters are exactly 32 values away from the same letter When using char in strings or with input/output functions like printf() and scanf() , the ASCII encoding ensures that numeric values are interpreted as readable characters.","title":"Common ASCII Values"},{"location":"wk_six/","text":"Week 6 Passing an Array to a Function To pass an array as an argument to a function simply use its name without square brackets. myFunc(myArr); When we pass an array to a function in C, we are really passing a pointer to the first element of the array. This means the function can modify the original array \u2014 we are not creating a copy. That is, we are passing by reference . When we pass an array in to a function which doesn't need to modify it, for example searching an array for max, we can pass it as const . This is like putting up guard rails to make sure that we don't actually change the array. Multi-Dimensional Arrays Multidimensional arrays are arrays within arrays. The simplest kind is a 2-dimensional array. In a 2-dimensional array, the first index is the row and the second is the column. Think of it like a spreadsheet: However, memory is only one-dimensional. Therefore, a 2D array is stored like this: The number of columns determines where each new row starts in memory. This is because C stores arrays in row-major order \u2014 row by row. We can compute the address of any element in a 2D array with this formula: start_loc + (rowNum * numberOfColumns) + colNum where start_loc is the address of the first element of the array. Multi-Dimensional Arrays with Initializer Lists When we initialize a 2d array, we can use additional sets of {} to signify rows int arr[3][3] = { {0, 1, 2}, {3, 4, 5}, {6, 7, 8} }; But this is just for readability \u2014 the underlying memory layout is the same as: int arr[3][3] = {0,1,2,3,4,5,6,7,8}; Both arrays will be identical, but the first is more readable. Passing a Multi-Dimensional Array to a Function When passing a multi-dimensional array to a function, we must explicitly specify the size of all dimensions except the first. This is because the compiler needs to know the number of columns to correctly calculate where each row starts in memory. void printArray(int arr[][3], size_t nRows); We do not need to specify the first dimension (number of rows). Looping Over Multi Dim Arrays Bob specifically said do not use variables like i or j when looping over arrays. Instead use things like r , c or row , col or something else that is similarly explicit. for (size_t row = 0; row < 3; ++row) { for (size_t col = 0; col < 4; ++col) { printf(\"%d \", arr[row][col]); } printf(\"\\n\"); } Variable-Length Arrays (VLAs) A variable-length array is an array whose size is not known at compile time. It can be created using a runtime value. int size; scanf(\"%d\", &size); int arr[size]; However, not all compilers support VLAs. Note: Bob very specifically said don't use VLAs in this course. If needed, dynamic arrays should be created using malloc, calloc, or realloc.","title":"Week 6"},{"location":"wk_six/#week-6","text":"","title":"Week 6"},{"location":"wk_six/#passing-an-array-to-a-function","text":"To pass an array as an argument to a function simply use its name without square brackets. myFunc(myArr); When we pass an array to a function in C, we are really passing a pointer to the first element of the array. This means the function can modify the original array \u2014 we are not creating a copy. That is, we are passing by reference . When we pass an array in to a function which doesn't need to modify it, for example searching an array for max, we can pass it as const . This is like putting up guard rails to make sure that we don't actually change the array.","title":"Passing an Array to a Function"},{"location":"wk_six/#multi-dimensional-arrays","text":"Multidimensional arrays are arrays within arrays. The simplest kind is a 2-dimensional array. In a 2-dimensional array, the first index is the row and the second is the column. Think of it like a spreadsheet: However, memory is only one-dimensional. Therefore, a 2D array is stored like this: The number of columns determines where each new row starts in memory. This is because C stores arrays in row-major order \u2014 row by row. We can compute the address of any element in a 2D array with this formula: start_loc + (rowNum * numberOfColumns) + colNum where start_loc is the address of the first element of the array.","title":"Multi-Dimensional Arrays"},{"location":"wk_six/#multi-dimensional-arrays-with-initializer-lists","text":"When we initialize a 2d array, we can use additional sets of {} to signify rows int arr[3][3] = { {0, 1, 2}, {3, 4, 5}, {6, 7, 8} }; But this is just for readability \u2014 the underlying memory layout is the same as: int arr[3][3] = {0,1,2,3,4,5,6,7,8}; Both arrays will be identical, but the first is more readable.","title":"Multi-Dimensional Arrays with Initializer Lists"},{"location":"wk_six/#passing-a-multi-dimensional-array-to-a-function","text":"When passing a multi-dimensional array to a function, we must explicitly specify the size of all dimensions except the first. This is because the compiler needs to know the number of columns to correctly calculate where each row starts in memory. void printArray(int arr[][3], size_t nRows); We do not need to specify the first dimension (number of rows).","title":"Passing a Multi-Dimensional Array to a Function"},{"location":"wk_six/#looping-over-multi-dim-arrays","text":"Bob specifically said do not use variables like i or j when looping over arrays. Instead use things like r , c or row , col or something else that is similarly explicit. for (size_t row = 0; row < 3; ++row) { for (size_t col = 0; col < 4; ++col) { printf(\"%d \", arr[row][col]); } printf(\"\\n\"); }","title":"Looping Over Multi Dim Arrays"},{"location":"wk_six/#variable-length-arrays-vlas","text":"A variable-length array is an array whose size is not known at compile time. It can be created using a runtime value. int size; scanf(\"%d\", &size); int arr[size]; However, not all compilers support VLAs. Note: Bob very specifically said don't use VLAs in this course. If needed, dynamic arrays should be created using malloc, calloc, or realloc.","title":"Variable-Length Arrays (VLAs)"},{"location":"wk_three/","text":"Week 3 Functions A function is a self-contained block of code designed to accomplish a specific task. Functions enable: Divide and conquer : Developing large programs by combining smaller, reusable parts. Abstraction : Hiding implementation details behind a meaningful name allowing a developer to use a function without worrying about the underlying implementation. Decomposition : Breaking complex problems into manageable components - when a function can't be defined easily, we can decompose it into a series of smaller functions which are better defined. Programs are easier to write, test, debug, and maintain when structured as a collection of functions. Functional Program Structure In C, all programs must have a main() function. It serves as the entry point of execution. However, instead of doing everything itself we can functionalize the program (breaking it into individual functions) allowing main() to focus on the overall logic while calling other functions to do the actual work. This setup reflects a hierarchical calling structure, where main() is the top-level caller ( boss ) and delegates tasks to helper functions ( workers ). Function Definition A function in C has the following definition: return_type function_name(parameter_list) { statements } The return_type tells the type returned from the function ( void if there is no return value). The function_name is the identifier for this function, it should be a clear, easy-to-understand name. The parameter_list is a comma-separated list of input variables and their types The statements are the actions taken by the function. If there is a return_type other than void the function must have a return statement in it. Example: int square(int number) { return number * number; } Function Prototype Recall that C executes code sequentially. If it sees a function caller before the definition of that function, it won't know what to do and the compiler will give an error. We can get around this, somewhat, by placing functions in the order that they are being called but this quickly becomes a mess and often can't even be fully achieved. To get around this, we can include a prototype near the start of the program that tells the compiler what a function looks like before it's used. int square(int number); This prototype allows the compiler to check that the function call has the right signature and also ensures that the return type is compatible for whatever the function is being called to do. Prototypes must end in a semicolon ; and do not have any of the statements listed. You can optionally omit the parameter names and only include types for the parameters int square(int); Note: the idea of prototypes didn't always exist in C . It is actually borrowed from C++ . Before this, the compiler wouldn't check the behaviour of functions meaning that no errors would be thrown at compilation but this led to more issues at runtime due to improper use of functions. Argument Coercion Function prototypes implicitly convert arguments to the appropriate type a process known as argument coercion . printf(\"%.3f\\n\", sqrt(4)); // this works despite sqrt expecting a double. //prints 2.000 We need to be careful with these coercions as if they are used incorrectly they can cause information to be lost. For example, if you pass a double to a function expecting an int the information after the decimal will be dropped. If that information was valuable this can lead to incorrect results. Furthermore, if a function expects a small type such as an short but we pass it a larger type such as a long we risk changing the value as any extra bits will be dropped from the long . Mixed-Type Expressions When we perform an operation which has multiple types, the compiler will make temporary copies of all the values to the highest type used: a process known as promotion . For example, if we have a double and a float everything is converted to a double because it is the higher size type. Function-Call Stack A stack is a common data-structure. It is often compared with a pile of plates. Fresh plates are placed on the top (known as being pushed onto the stack) and when they are removed we also grab from the top (and pop off the stack). Stacks are last-in, first-out (LIFO) . The function-call stack is what supports the underlying function call and return for a program. When we call a function, we might call other functions. Each function needs to remember who to return its value to. The function-call stack makes this easy. Each time a function calls another function, we push a stack frame containing the return address for the new function to return to the old function. Once a function returns, the associated stack frame is popped and returns control to the return address that is specified in that stack frame. Because it is a stack, each function will always* find its return address at the top of the stack, once it is used it is popped off the stack so the next function sees the correct address. If we push too many functions to the stack, we will eventually run out of memory and will have a stack overflow error crashing the program. Pass Arguments by Value and by Reference In programming, there are two ways to pass an argument into a function: pass by value and pass by reference . Passing by value means that we copy the value of an argument into the function. Since the function then works on a copy, it does not affect the original variable's value. int c = 5; superFunction(c); // will print 5000; printf(\"outside: %d\\n\", c); // will print 5 void superFunction(int num){ num *= 1000; printf(\"inside: %d\\n\", num); return } Passing by reference means that we pass the actual variable (or at least a reference to it) into the function. This means that the function does modify the original variable's value as a result. In C all arguments are passed by value . With that said, we can use pointers to achieve pass by reference functionality. Random-Number Generation In C the standard library <stdlib.h> has a few useful functions that we can use to generate random numbers. In this course we will look at rand() and srand() . To create a random value we can simply use rand() as follows: int value = rand(); . This will generate a random value between 0 and RAND_MAX (which is a symbolic constant defined in <stdlib.h> and is at least 32,767 but can be higher depending on system/compiler). Note: even though its defined as at least 32,767, the value is always of type int (or more clearly signed int ) and not short . We often want to limit the range of possible values returned when we generate a random number. For example, if we wanted to simulate a dice roll, we would only want 1, 2, 3, 4, 5, 6 as our possible values but as we see rand() return between 0 and RAND_MAX which is way more numbers than we want. To get around this, we can use the modulo operator and work just with remainders. int diceValue = 1 + (rand() % 6) // note: rand() % 6 will return a number between 0 and 5. We add 1 to *shift* the result to 1 through 6. This is known as scaling . In our example above, 6 is our scaling factor and adding one is our shift . Seeds and srand() Each subsequent call to rand() calculates a new random number based on the previous result. This works within a single execution of the program, however if we run the program again we will discover that it returns the exact same results the next time it is run. This is because rand() starts with a default seed or starting value (usually just 1). To get randomized results for every execution, we can use the srand() function to s eed rand() . Note that this function just changes the seed value that will be used by rand() . After seeding, we still use the regular rand() function to generate our random numbers. That is, we only run srand() once to set things up. We can pass any number to srand() but if we hardcode that number in the program we will end up with the same issue, namely that every execution will start with the same seed and thus have the same results. time(NULL) To get around this, we can use time(NULL) as our seed: srand(time(NULL)); . time(NULL) returns the number of seconds that have passed since midnight Jan 1, 1970 and therefore is changing every second. Secure Random Number Generation The standard C rand() function is fine for textbook examples but is not suitable for secure or industrial-strength applications. According to the C standard: \"There are no guarantees as to the quality of the random sequence produced, and some implementations are known to produce sequences with distressingly non-random low-order bits.\" Secure Alternatives for Production For cryptography or any security-critical task, rand() is not safe. Instead, use platform-specific secure random-number generators: Platform Recommended Function Notes Windows BCryptGenRandom Part of the Cryptography API: Next Generation ( docs ) Linux / POSIX random View details with man random in terminal macOS arc4random View details with man arc4random in terminal Refer to the CERT Secure Coding Guideline: MSC30-C: Do not use the rand() function for generating pseudorandom numbers Always use secure generators when random numbers must not be predictable.","title":"Week 3"},{"location":"wk_three/#week-3","text":"","title":"Week 3"},{"location":"wk_three/#functions","text":"A function is a self-contained block of code designed to accomplish a specific task. Functions enable: Divide and conquer : Developing large programs by combining smaller, reusable parts. Abstraction : Hiding implementation details behind a meaningful name allowing a developer to use a function without worrying about the underlying implementation. Decomposition : Breaking complex problems into manageable components - when a function can't be defined easily, we can decompose it into a series of smaller functions which are better defined. Programs are easier to write, test, debug, and maintain when structured as a collection of functions.","title":"Functions"},{"location":"wk_three/#functional-program-structure","text":"In C, all programs must have a main() function. It serves as the entry point of execution. However, instead of doing everything itself we can functionalize the program (breaking it into individual functions) allowing main() to focus on the overall logic while calling other functions to do the actual work. This setup reflects a hierarchical calling structure, where main() is the top-level caller ( boss ) and delegates tasks to helper functions ( workers ).","title":"Functional Program Structure"},{"location":"wk_three/#function-definition","text":"A function in C has the following definition: return_type function_name(parameter_list) { statements } The return_type tells the type returned from the function ( void if there is no return value). The function_name is the identifier for this function, it should be a clear, easy-to-understand name. The parameter_list is a comma-separated list of input variables and their types The statements are the actions taken by the function. If there is a return_type other than void the function must have a return statement in it. Example: int square(int number) { return number * number; }","title":"Function Definition"},{"location":"wk_three/#function-prototype","text":"Recall that C executes code sequentially. If it sees a function caller before the definition of that function, it won't know what to do and the compiler will give an error. We can get around this, somewhat, by placing functions in the order that they are being called but this quickly becomes a mess and often can't even be fully achieved. To get around this, we can include a prototype near the start of the program that tells the compiler what a function looks like before it's used. int square(int number); This prototype allows the compiler to check that the function call has the right signature and also ensures that the return type is compatible for whatever the function is being called to do. Prototypes must end in a semicolon ; and do not have any of the statements listed. You can optionally omit the parameter names and only include types for the parameters int square(int); Note: the idea of prototypes didn't always exist in C . It is actually borrowed from C++ . Before this, the compiler wouldn't check the behaviour of functions meaning that no errors would be thrown at compilation but this led to more issues at runtime due to improper use of functions.","title":"Function Prototype"},{"location":"wk_three/#argument-coercion","text":"Function prototypes implicitly convert arguments to the appropriate type a process known as argument coercion . printf(\"%.3f\\n\", sqrt(4)); // this works despite sqrt expecting a double. //prints 2.000 We need to be careful with these coercions as if they are used incorrectly they can cause information to be lost. For example, if you pass a double to a function expecting an int the information after the decimal will be dropped. If that information was valuable this can lead to incorrect results. Furthermore, if a function expects a small type such as an short but we pass it a larger type such as a long we risk changing the value as any extra bits will be dropped from the long .","title":"Argument Coercion"},{"location":"wk_three/#mixed-type-expressions","text":"When we perform an operation which has multiple types, the compiler will make temporary copies of all the values to the highest type used: a process known as promotion . For example, if we have a double and a float everything is converted to a double because it is the higher size type.","title":"Mixed-Type Expressions"},{"location":"wk_three/#function-call-stack","text":"A stack is a common data-structure. It is often compared with a pile of plates. Fresh plates are placed on the top (known as being pushed onto the stack) and when they are removed we also grab from the top (and pop off the stack). Stacks are last-in, first-out (LIFO) . The function-call stack is what supports the underlying function call and return for a program. When we call a function, we might call other functions. Each function needs to remember who to return its value to. The function-call stack makes this easy. Each time a function calls another function, we push a stack frame containing the return address for the new function to return to the old function. Once a function returns, the associated stack frame is popped and returns control to the return address that is specified in that stack frame. Because it is a stack, each function will always* find its return address at the top of the stack, once it is used it is popped off the stack so the next function sees the correct address. If we push too many functions to the stack, we will eventually run out of memory and will have a stack overflow error crashing the program.","title":"Function-Call Stack"},{"location":"wk_three/#pass-arguments-by-value-and-by-reference","text":"In programming, there are two ways to pass an argument into a function: pass by value and pass by reference . Passing by value means that we copy the value of an argument into the function. Since the function then works on a copy, it does not affect the original variable's value. int c = 5; superFunction(c); // will print 5000; printf(\"outside: %d\\n\", c); // will print 5 void superFunction(int num){ num *= 1000; printf(\"inside: %d\\n\", num); return } Passing by reference means that we pass the actual variable (or at least a reference to it) into the function. This means that the function does modify the original variable's value as a result. In C all arguments are passed by value . With that said, we can use pointers to achieve pass by reference functionality.","title":"Pass Arguments by Value and by Reference"},{"location":"wk_three/#random-number-generation","text":"In C the standard library <stdlib.h> has a few useful functions that we can use to generate random numbers. In this course we will look at rand() and srand() . To create a random value we can simply use rand() as follows: int value = rand(); . This will generate a random value between 0 and RAND_MAX (which is a symbolic constant defined in <stdlib.h> and is at least 32,767 but can be higher depending on system/compiler). Note: even though its defined as at least 32,767, the value is always of type int (or more clearly signed int ) and not short . We often want to limit the range of possible values returned when we generate a random number. For example, if we wanted to simulate a dice roll, we would only want 1, 2, 3, 4, 5, 6 as our possible values but as we see rand() return between 0 and RAND_MAX which is way more numbers than we want. To get around this, we can use the modulo operator and work just with remainders. int diceValue = 1 + (rand() % 6) // note: rand() % 6 will return a number between 0 and 5. We add 1 to *shift* the result to 1 through 6. This is known as scaling . In our example above, 6 is our scaling factor and adding one is our shift .","title":"Random-Number Generation"},{"location":"wk_three/#seeds-and-srand","text":"Each subsequent call to rand() calculates a new random number based on the previous result. This works within a single execution of the program, however if we run the program again we will discover that it returns the exact same results the next time it is run. This is because rand() starts with a default seed or starting value (usually just 1). To get randomized results for every execution, we can use the srand() function to s eed rand() . Note that this function just changes the seed value that will be used by rand() . After seeding, we still use the regular rand() function to generate our random numbers. That is, we only run srand() once to set things up. We can pass any number to srand() but if we hardcode that number in the program we will end up with the same issue, namely that every execution will start with the same seed and thus have the same results.","title":"Seeds and srand()"},{"location":"wk_three/#timenull","text":"To get around this, we can use time(NULL) as our seed: srand(time(NULL)); . time(NULL) returns the number of seconds that have passed since midnight Jan 1, 1970 and therefore is changing every second.","title":"time(NULL)"},{"location":"wk_three/#secure-random-number-generation","text":"The standard C rand() function is fine for textbook examples but is not suitable for secure or industrial-strength applications. According to the C standard: \"There are no guarantees as to the quality of the random sequence produced, and some implementations are known to produce sequences with distressingly non-random low-order bits.\"","title":"Secure Random Number Generation"},{"location":"wk_three/#secure-alternatives-for-production","text":"For cryptography or any security-critical task, rand() is not safe. Instead, use platform-specific secure random-number generators: Platform Recommended Function Notes Windows BCryptGenRandom Part of the Cryptography API: Next Generation ( docs ) Linux / POSIX random View details with man random in terminal macOS arc4random View details with man arc4random in terminal Refer to the CERT Secure Coding Guideline: MSC30-C: Do not use the rand() function for generating pseudorandom numbers Always use secure generators when random numbers must not be predictable.","title":"Secure Alternatives for Production"},{"location":"wk_two/","text":"Week 2 Algorithms Definition: An algorithm is a procedure for solving a problem, defined by: The actions to execute. The order in which these actions execute. The order of statement execution is called program control. Control Structures By default, C programs execute statements in the order they are written (sequential execution). However, control structures allow transferring control to execute statements out of sequence. There are three types: Sequence Structure: Statements execute in the order written. Selection Structures: if, if...else, and switch choose the next statement based on a condition. Iteration Structures: for, while, and do...while repeat statements until a condition is met. Selection Structures if and if...else Statements The if statement evaluates a condition and executes a block if true. An optional else block executes if false. Example: int x = 5; if (x > 0) { printf(\"x is positive\\n\"); } else { printf(\"x is non-positive\\n\"); } // Output: x is positive Ternary Conditional Operator The ternary operator ( ?: ) is a concise alternative to if...else for simple conditions. It returns the value after ? if the condition is true, or the value after : if false. int x = 5; puts(x > 0 ? \"good\" : \"bad\"); // Output: good Note: Use the ternary operator for simple expressions but probably best to avoid for more complex expressions as it can reduce readability for complex logic. Short-Circuit Evaluation In C , logical operators ( && and || ) use short-circuit evaluation. If the result of an expression can be determined early, the remaining parts are not evaluated. For && ( AND ): If the first condition is false , the second is not evaluated. For || ( OR ): If the first condition is true , the second is not evaluated. Example: int x = 0, y = 5; if (x != 0 && y / x > 2) { // y / x not evaluated due to x == 0 printf(\"This won't print\\n\"); } This prevents errors like division by zero. switch() Statement switch provides a clean way to branch based on the value of a single variable (usually int or char ). It\u2019s often used instead of long if...else if chains. int grade = 2; switch (grade) { case 1: puts(\"Excellent\"); break; case 2: puts(\"Good\"); break; case 3: puts(\"Fair\"); break; default: puts(\"Invalid\"); } If we don't put a break; after a case execution will fall through to the next case. Sometimes this is intentional when multiple values will have the same response. Other times, this is a bug and will lead to unexpected behaviour. case 1: // Fall-through intentional case 2: puts(\"Grade is 1 or 2\"); break; Iteration Structures while Loop The while loop repeats as long as a condition is true, checking the condition before each iteration. int i = 3; while (i < 10) { printf(\"%d \", i); i++; } // Output: 3 4 5 6 7 8 9 do...while Loop The do...while loop executes at least once, checking the condition after each iteration. int i = 3; do { printf(\"%d \", i); i++; } while (i < 4); // Output: 3 for Loop The for loop is used for iterations with a known number of repetitions, combining initialization, condition, and increment. for (int i = 0; i < 5; i++) { printf(\"%d \", i); } // Output: 0 1 2 3 4 Pre-Increment vs. Post-Increment Pre-increment ( ++i ): Increments i before using its value. Post-increment ( i++ ): Uses i \u2019s value, then increments it. Example: int i = 0; printf(\"%d\\n\", i++); // Prints 0, then i becomes 1 printf(\"%d\\n\", ++i); // Increments i to 2, then prints 2 Bob's Preference: Use pre-increment ( ++i ) in loops for slight performance benefits (avoids creating a temporary copy) and clarity. In a for loop, the increment step (e.g., i++ or ++i in for (int i = 0; i < 5; i++) ) occurs after the loop body executes, so the choice of pre- or post-increment doesn\u2019t affect the loop\u2019s iteration behavior. Both produce the same sequence of loop iterations. However, within the loop body, the choice matters if the incremented value is used. For example, if you use i++ or ++i to modify another variable, the result differs. Loop Exit Conditions When using different increment types or loop structures, carefully consider when the loop exits: Integer increments: Ensure the condition accounts for the final value. int i = 0; while (i < 5) { printf(\"%d \", i); i += 2; // Increments by 2 } // Output: 0 2 4 Floating-point increments: Be cautious with floating-point conditions due to precision issues (basically, never do this). float i = 0.0; while (i < 1.0) { printf(\"%.1f \", i); i += 0.1; } // May not stop exactly at 1.0 due to floating-point imprecision Loop type choice: Use while for condition-driven loops. Use do...while when at least one iteration is needed. Use for for counted loops with clear start and end points. Casting Numbers When dividing two integers, the result is an integer, truncating any decimal part. To retain decimals, cast one or both operands to float or double . int a = 2, b = 3; float result = (float)a / b; // Cast a to float printf(\"%.2f\\n\", result); // %.2f formats to 2 decimal places // Output: 0.67 Note: Use %.nf in printf to specify n decimal places (e.g., %.2f for two decimals). Arithmetic Overflow The <limits.h> header provides constraints for various types based on the underlying system limits. Example: #include <limits.h> #include <stdio.h> int main(void) { int x = INT_MAX; if (x > INT_MAX - 1) { // Check for overflow printf(\"Cannot increment without overflow\\n\"); } else { x++; } return 0; }","title":"Week 2"},{"location":"wk_two/#week-2","text":"","title":"Week 2"},{"location":"wk_two/#algorithms","text":"Definition: An algorithm is a procedure for solving a problem, defined by: The actions to execute. The order in which these actions execute. The order of statement execution is called program control.","title":"Algorithms"},{"location":"wk_two/#control-structures","text":"By default, C programs execute statements in the order they are written (sequential execution). However, control structures allow transferring control to execute statements out of sequence. There are three types: Sequence Structure: Statements execute in the order written. Selection Structures: if, if...else, and switch choose the next statement based on a condition. Iteration Structures: for, while, and do...while repeat statements until a condition is met.","title":"Control Structures"},{"location":"wk_two/#selection-structures","text":"","title":"Selection Structures"},{"location":"wk_two/#if-and-ifelse-statements","text":"The if statement evaluates a condition and executes a block if true. An optional else block executes if false. Example: int x = 5; if (x > 0) { printf(\"x is positive\\n\"); } else { printf(\"x is non-positive\\n\"); } // Output: x is positive","title":"if and if...else Statements"},{"location":"wk_two/#ternary-conditional-operator","text":"The ternary operator ( ?: ) is a concise alternative to if...else for simple conditions. It returns the value after ? if the condition is true, or the value after : if false. int x = 5; puts(x > 0 ? \"good\" : \"bad\"); // Output: good Note: Use the ternary operator for simple expressions but probably best to avoid for more complex expressions as it can reduce readability for complex logic.","title":"Ternary Conditional Operator"},{"location":"wk_two/#short-circuit-evaluation","text":"In C , logical operators ( && and || ) use short-circuit evaluation. If the result of an expression can be determined early, the remaining parts are not evaluated. For && ( AND ): If the first condition is false , the second is not evaluated. For || ( OR ): If the first condition is true , the second is not evaluated. Example: int x = 0, y = 5; if (x != 0 && y / x > 2) { // y / x not evaluated due to x == 0 printf(\"This won't print\\n\"); } This prevents errors like division by zero.","title":"Short-Circuit Evaluation"},{"location":"wk_two/#switch-statement","text":"switch provides a clean way to branch based on the value of a single variable (usually int or char ). It\u2019s often used instead of long if...else if chains. int grade = 2; switch (grade) { case 1: puts(\"Excellent\"); break; case 2: puts(\"Good\"); break; case 3: puts(\"Fair\"); break; default: puts(\"Invalid\"); } If we don't put a break; after a case execution will fall through to the next case. Sometimes this is intentional when multiple values will have the same response. Other times, this is a bug and will lead to unexpected behaviour. case 1: // Fall-through intentional case 2: puts(\"Grade is 1 or 2\"); break;","title":"switch() Statement"},{"location":"wk_two/#iteration-structures","text":"","title":"Iteration Structures"},{"location":"wk_two/#while-loop","text":"The while loop repeats as long as a condition is true, checking the condition before each iteration. int i = 3; while (i < 10) { printf(\"%d \", i); i++; } // Output: 3 4 5 6 7 8 9","title":"while Loop"},{"location":"wk_two/#dowhile-loop","text":"The do...while loop executes at least once, checking the condition after each iteration. int i = 3; do { printf(\"%d \", i); i++; } while (i < 4); // Output: 3","title":"do...while Loop"},{"location":"wk_two/#for-loop","text":"The for loop is used for iterations with a known number of repetitions, combining initialization, condition, and increment. for (int i = 0; i < 5; i++) { printf(\"%d \", i); } // Output: 0 1 2 3 4","title":"for Loop"},{"location":"wk_two/#pre-increment-vs-post-increment","text":"Pre-increment ( ++i ): Increments i before using its value. Post-increment ( i++ ): Uses i \u2019s value, then increments it. Example: int i = 0; printf(\"%d\\n\", i++); // Prints 0, then i becomes 1 printf(\"%d\\n\", ++i); // Increments i to 2, then prints 2 Bob's Preference: Use pre-increment ( ++i ) in loops for slight performance benefits (avoids creating a temporary copy) and clarity. In a for loop, the increment step (e.g., i++ or ++i in for (int i = 0; i < 5; i++) ) occurs after the loop body executes, so the choice of pre- or post-increment doesn\u2019t affect the loop\u2019s iteration behavior. Both produce the same sequence of loop iterations. However, within the loop body, the choice matters if the incremented value is used. For example, if you use i++ or ++i to modify another variable, the result differs.","title":"Pre-Increment vs. Post-Increment"},{"location":"wk_two/#loop-exit-conditions","text":"When using different increment types or loop structures, carefully consider when the loop exits: Integer increments: Ensure the condition accounts for the final value. int i = 0; while (i < 5) { printf(\"%d \", i); i += 2; // Increments by 2 } // Output: 0 2 4 Floating-point increments: Be cautious with floating-point conditions due to precision issues (basically, never do this). float i = 0.0; while (i < 1.0) { printf(\"%.1f \", i); i += 0.1; } // May not stop exactly at 1.0 due to floating-point imprecision","title":"Loop Exit Conditions"},{"location":"wk_two/#loop-type-choice","text":"Use while for condition-driven loops. Use do...while when at least one iteration is needed. Use for for counted loops with clear start and end points.","title":"Loop type choice:"},{"location":"wk_two/#casting-numbers","text":"When dividing two integers, the result is an integer, truncating any decimal part. To retain decimals, cast one or both operands to float or double . int a = 2, b = 3; float result = (float)a / b; // Cast a to float printf(\"%.2f\\n\", result); // %.2f formats to 2 decimal places // Output: 0.67 Note: Use %.nf in printf to specify n decimal places (e.g., %.2f for two decimals).","title":"Casting Numbers"},{"location":"wk_two/#arithmetic-overflow","text":"The <limits.h> header provides constraints for various types based on the underlying system limits. Example: #include <limits.h> #include <stdio.h> int main(void) { int x = INT_MAX; if (x > INT_MAX - 1) { // Check for overflow printf(\"Cannot increment without overflow\\n\"); } else { x++; } return 0; }","title":"Arithmetic Overflow"}]}